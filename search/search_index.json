{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":"<p>This documentation provides guidance for using the FFT-Analyzer, a tool that allows users to select two channels from a .h5 signal file for signal processing. The tool offers various methods to process and display the results, with options to export the data. It was developed at TU Berlin for the course Python &amp; Akustik.</p>"},{"location":"api_documentation/","title":"API Documentation","text":"<p>The FFT Analysator API consist of two classes. </p> <p>Preprocessing: Handles preprocessing </p> <p>Signal_processing: Handles calculation</p> <p>An example of those classes can be seen below. For more Information please refer to the User Manual and Documentation. </p> Initializing Preprocessing<pre><code>import fft_analysator.analysis.preprocessing as pp\n\nmy_file_path = 'path/to/file/myFile.h5' # Path to h5-File\nmy_block_size = 2048 # Choose block size\n\npreproc = pp.(my_file_path, block_size = my_block_size)\n</code></pre> Calculating with Signal Processing<pre><code>import fft_analysator.analysis.signal_processing as sp\n\nmy_channels = [1,4] # Define your channles\nmy_window = 'Hanning' # Select a window. \nmy_overlap = '75%' # Select overlap\n\nsignal_proc = sp.Signal_Processing(channels=[], file_path=my_file_path, block_size=my_block_size)\n\n# One is able to change the parameters by using the method \"set_parameters\"\n\nsignal_proc.set_parameters(my_channles, my_window, my_overlap)\n\n# Calculating now for example the CSM (Cross spectral Matrix). The CSM is a three dimensional array \n# with dimensions [Frequencies, Input channel, Output Channel], where in our case the Input channel is 1 and\n# Output channel is 4. The data is complex valued. \n\ncsm_data = signal_proc.csm\n\ncsm_data[:,0,1] # Cross spectral density between channel 1 and 4\ncsm_data[:,0,0] # Auto spectral density of channel 1\ncsm_data[:,1,1] # Cross spectral density of channel 4\n</code></pre>"},{"location":"dev_backend_documentation/","title":"Backend Documentation","text":""},{"location":"dev_backend_documentation/#preprocessing","title":"Preprocessing","text":""},{"location":"dev_backend_documentation/#fft_analysator.analysis.preprocessing","title":"preprocessing","text":""},{"location":"dev_backend_documentation/#fft_analysator.analysis.preprocessing.Preprocess","title":"Preprocess","text":"<pre><code>Preprocess(file_paths=None, block_size=1024)\n</code></pre> <p>The Preprocess class handles everything after importing the user file. It is an interface between Acoular and our internal Signalprocessing class. It contains information about the block size, data, channel count and size and sample frequency. It is able to return the complete data as a Numpy array or iterate over the defined block size.</p> <p>Parameters:</p> Name Type Description Default <code>file_paths</code> <code>object</code> <p>Get the callback to the data object</p> <code>None</code> <code>block_size</code> <code>int</code> <p>Length of data block.</p> <code>1024</code> Source code in <code>src/fft_analysator/analysis/preprocessing.py</code> <pre><code>def __init__(self, file_paths=None, block_size=1024):\n\n    self.file_paths = file_paths\n    self.block_size = block_size\n\n    if file_paths:\n        self.table_key = self.get_table_names()[0]\n        self.source = ac.TimeSamples(name=self.file_paths)\n        self.source_result = self.source.result(num=self.block_size)\n        self.selected_data_block = next(self.source_result)\n\n    self.current_block_idx = 0\n    self.data = None\n    self.channel_count = None\n    self.channel_size = None\n    self.selected_channel_data = np.array([])\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.preprocessing.Preprocess.get_abtastrate","title":"get_abtastrate","text":"<pre><code>get_abtastrate()\n</code></pre> <p>Get_abtastrate returns the sample_freq from the current .h5 file via Acoular</p> Source code in <code>src/fft_analysator/analysis/preprocessing.py</code> <pre><code>def get_abtastrate(self):\n    \"\"\"\n    Get_abtastrate returns the sample_freq from the current .h5 file via Acoular\n    \"\"\"\n    abtastrate = self.source.sample_freq\n    return abtastrate\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.preprocessing.Preprocess.get_channel_count","title":"get_channel_count","text":"<pre><code>get_channel_count()\n</code></pre> <p>Get_channel_count returns the number of channels of the current .h5 file</p> Source code in <code>src/fft_analysator/analysis/preprocessing.py</code> <pre><code>def get_channel_count(self):\n    \"\"\"\n    Get_channel_count returns the number of channels of the current .h5 file\n    \"\"\"\n    count = self.source.numchannels\n    return count\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.preprocessing.Preprocess.get_channel_size","title":"get_channel_size","text":"<pre><code>get_channel_size()\n</code></pre> <p>Get_channel_size returns the size of the current channel</p> Source code in <code>src/fft_analysator/analysis/preprocessing.py</code> <pre><code>def get_channel_size(self):\n    \"\"\"\n    Get_channel_size returns the size of the current channel\n    \"\"\"\n    #size = np.array(self.source)[:, self.current_channel].shape[0]\n    size = np.array(self.converted_file)[:, self.current_channel].shape[0]\n    return size\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.preprocessing.Preprocess.get_table_names","title":"get_table_names","text":"<pre><code>get_table_names()\n</code></pre> <p>Get_table_names returns a list of all data set keyword contained in the current .h5 File</p> Source code in <code>src/fft_analysator/analysis/preprocessing.py</code> <pre><code>def get_table_names(self):\n    \"\"\"\n    Get_table_names returns a list of all data set keyword contained in the current .h5 File\n    \"\"\"\n    with h5py.File(self.file_paths, 'r') as file:\n        # Zugriff auf den gew\u00fcnschten Datensatz\n        keys = list(file.keys())\n\n    return keys\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.preprocessing.Preprocess.reinitialize_source","title":"reinitialize_source","text":"<pre><code>reinitialize_source()\n</code></pre> <p>The reinitialize_source function reinitializes the generator from Acoular. It is used for returning to already viewed data blocks.</p> Source code in <code>src/fft_analysator/analysis/preprocessing.py</code> <pre><code>def reinitialize_source(self):\n    \"\"\"\n    The reinitialize_source function reinitializes the generator from Acoular. It is used for returning to already\n    viewed data blocks.\n    \"\"\"\n    self.current_block_idx = 0\n    self.source = ac.TimeSamples(name=self.file_paths)\n    self.source_result = self.source.result(num=self.block_size)\n    self.selected_data_block = next(self.source_result)\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.preprocessing.Preprocess.set_channel_data","title":"set_channel_data","text":"<pre><code>set_channel_data(channel)\n</code></pre> <p>Set_channel_data sets returns the complete channel by iterating over the generator of Acoular and saving the data blocks in a Numpy Array.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>Channel number.</p> required Source code in <code>src/fft_analysator/analysis/preprocessing.py</code> <pre><code>def set_channel_data(self, channel):\n    \"\"\"\n    Set_channel_data sets returns the complete channel by iterating over the generator of Acoular and\n    saving the data blocks in a Numpy Array.\n\n    Args:\n        channel (int): Channel number.\n    \"\"\"\n    loop_list = []\n    for data in self.source_result:\n        loop_list.extend(data[:, channel])\n    self.selected_channel_data = np.array(loop_list)\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.preprocessing.Preprocess.set_channel_on_data_block","title":"set_channel_on_data_block","text":"<pre><code>set_channel_on_data_block(channel)\n</code></pre> <p>Set_channel_data_on_data_block sets returns the block data of a channel as a Numpy Array.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>Channel number.</p> required Source code in <code>src/fft_analysator/analysis/preprocessing.py</code> <pre><code>def set_channel_on_data_block(self, channel):\n    \"\"\"\n    Set_channel_data_on_data_block sets returns the block data of a channel as a Numpy Array.\n\n    Args:\n        channel (int): Channel number.\n    \"\"\"\n    return self.selected_data_block[:, channel]\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.preprocessing.Preprocess.set_current_channel","title":"set_current_channel","text":"<pre><code>set_current_channel(channel)\n</code></pre> <p>Set_current_channel sets the attribute current_channel by taking a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>Channel number switching to.</p> required Source code in <code>src/fft_analysator/analysis/preprocessing.py</code> <pre><code>def set_current_channel(self, channel):\n    \"\"\"\n    Set_current_channel sets the attribute current_channel by taking a channel.\n\n    Args:\n        channel (int): Channel number switching to.\n    \"\"\"\n    self.current_channel = channel\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.preprocessing.Preprocess.set_data_block_to_idx","title":"set_data_block_to_idx","text":"<pre><code>set_data_block_to_idx(idx)\n</code></pre> <p>Set_data_block_to_idx sets the attribute selected_data_block by selecting a specific element of the generator from Acoular and saving this data blocks in a Numpy Array.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>Idx element to which the generator iterates to.</p> required Source code in <code>src/fft_analysator/analysis/preprocessing.py</code> <pre><code>def set_data_block_to_idx(self, idx):\n    \"\"\"\n    Set_data_block_to_idx sets the attribute selected_data_block by selecting a specific element of\n    the generator from Acoular and saving this data blocks in a Numpy Array.\n\n    Args:\n        idx (int): Idx element to which the generator iterates to.\n    \"\"\"\n    self.reinitialize_source()\n    try:\n        self.current_block_idx = idx\n        if idx &gt; 0:\n            for i in range(idx):\n                self.selected_data_block = next(self.source_result)\n        print('previous')\n    except StopIteration:\n        print('End of file reached')\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.preprocessing.Preprocess.set_next_data_block","title":"set_next_data_block","text":"<pre><code>set_next_data_block()\n</code></pre> <p>Set_next_data_block sets the attribute selected_data_block by selecting the next element of the generator from Acoular and saving this data blocks in a Numpy Array.</p> Source code in <code>src/fft_analysator/analysis/preprocessing.py</code> <pre><code>def set_next_data_block(self):\n    \"\"\"\n    Set_next_data_block sets the attribute selected_data_block by selecting the next element of\n    the generator from Acoular and saving this data blocks in a Numpy Array.\n    \"\"\"\n    self.current_block_idx += 1\n    self.selected_data_block = next(self.source_result)\n    print('next')\n</code></pre>"},{"location":"dev_backend_documentation/#signal-processing","title":"Signal Processing","text":""},{"location":"dev_backend_documentation/#fft_analysator.analysis.signal_processing","title":"signal_processing","text":""},{"location":"dev_backend_documentation/#fft_analysator.analysis.signal_processing.Signal_Process","title":"Signal_Process","text":"<pre><code>Signal_Process(channels=[], file_path=None, window='Hanning', block_size=1024, overlap='50%', data_callback=None)\n</code></pre> <p>The Signal_Process class handles every signal processing method block-wise and returns its results as a Numpy Array. It is initialized by a required the file_path, a window option for the Fourier transformation, a given block_size and an Overlap percentage. Possible signal processing are CSM calculation (Cross Spectral Matrix), coherence between two signals, frequency and impulse response between input and output data and cross/auto correlation between two given signals.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>object</code> <p>Get the callback to the data object</p> <code>None</code> <code>window</code> <code>string</code> <p>window function for the fourier transformation: Allowed options: 'Rectangular','Hanning',</p> <code>'Hanning'</code> <code>block_size</code> <code>int</code> <p>Length of data block. Allowed values: 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536</p> <code>1024</code> <code>overlap</code> <code>string</code> <p>Overlap percentage between two blocks for the Welch-Method. Allowed options: 'None','50%',</p> <code>'50%'</code> Source code in <code>src/fft_analysator/analysis/signal_processing.py</code> <pre><code>def __init__(self, channels=[], file_path=None, window='Hanning', block_size=1024, overlap='50%', data_callback=None):\n    self.file_path = file_path\n    self.window = window\n    self.block_size = block_size\n    self.overlap = overlap\n    self.channels = channels\n    self.current_data = None\n    self.impulse_response_data = None\n    self.amplitude_response_data = None\n    self.phase_response_data = None\n    self.data_callback = data_callback\n    self.p0 = 20*10**-6 #auditory threshold\n\n    if file_path:\n\n        self.source = ac.MaskedTimeSamples(name=self.file_path)\n        self.abtastrate = self.source.sample_freq\n        self.numchannels_total = self.source.numchannels_total\n        self.invalid_channel_list = []\n        self.powerspectra = None\n\n        if channels:\n            if len(channels) == 1:\n                self.input_channel = self.channels[0]\n                self.output_channel = self.channels[0]\n            else:\n                self.input_channel = self.channels[0]\n                self.output_channel = self.channels[1]\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.signal_processing.Signal_Process.SPL","title":"SPL","text":"<pre><code>SPL(channel)\n</code></pre> <p>The SPL function calculates the Sound Pressure Level of the current signal.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>Channel number.</p> required Source code in <code>src/fft_analysator/analysis/signal_processing.py</code> <pre><code>def SPL(self,channel):\n    \"\"\"\n    The SPL function calculates the Sound Pressure Level of the current signal.\n\n    Args:\n        channel (int): Channel number.\n\n    \"\"\"\n\n    return 20*np.log10(np.abs(self.data_callback.set_channel_on_data_block(channel))/self.p0)\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.signal_processing.Signal_Process.coherence","title":"coherence","text":"<pre><code>coherence()\n</code></pre> <p>The coherence function calculates the coherence between two given signals.</p> Source code in <code>src/fft_analysator/analysis/signal_processing.py</code> <pre><code>def coherence(self):\n    \"\"\"\n    The coherence function calculates the coherence between two given signals.\n\n    Args:\n        None\n    \"\"\"\n    csm_matrix = self.csm()\n\n    if self.input_channel == self.output_channel:\n        coherence = np.abs(csm_matrix[:, 0, 0].real)**2 / (csm_matrix[:, 0, 0].real * csm_matrix[:, 0, 0].real)\n    else:\n        coherence = np.abs(csm_matrix[:, 0, 1])**2 / (csm_matrix[:, 0, 0].real * csm_matrix[:, 1, 1].real)\n\n    self.current_data = coherence\n\n    return self.current_data\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.signal_processing.Signal_Process.correlation","title":"correlation","text":"<pre><code>correlation(type=None)\n</code></pre> <p>The correlation function calculates the correlation response between the two given signals.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>string</code> <p>Determines if an auto or cross correlation is being calculated. Allowed options: 'xx', 'yy', 'xy'</p> <code>None</code> Source code in <code>src/fft_analysator/analysis/signal_processing.py</code> <pre><code>def correlation(self,type=None):\n    \"\"\"\n    The correlation function calculates the correlation response between the two given signals.\n\n    Args:\n        type (string): Determines if an auto or cross correlation is being calculated. Allowed options: 'xx', 'yy', 'xy'\n    \"\"\"\n    csm_matrix = self.csm()\n    N = len(csm_matrix[:, 0, 0])\n\n    if type == 'xx':\n            corr = np.fft.fftshift(np.fft.irfft(csm_matrix[:, 0, 0].real, n=N))\n    elif type == 'yy':\n        if self.input_channel == self.output_channel:\n            corr = np.fft.fftshift(np.fft.irfft(csm_matrix[:, 0, 0].real, n=N))\n        else:\n            corr = np.fft.fftshift(np.fft.irfft(csm_matrix[:, 1, 1].real, n=N))\n    elif type == 'xy':\n        if self.input_channel == self.output_channel:\n            corr = np.fft.fftshift(np.fft.irfft(csm_matrix[:, 0, 0].real, n=N))\n        else:\n            corr = np.fft.fftshift(np.fft.irfft(csm_matrix[:, 0, 1], n=N))\n\n    self.current_data = corr / np.max(np.abs(corr)) # normalize the correlation to max_value\n    return self.current_data\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.signal_processing.Signal_Process.create_correlation_axis","title":"create_correlation_axis","text":"<pre><code>create_correlation_axis(N)\n</code></pre> <p>The create_correlation_axis function creates the x-Axis for the correlation function Args:     N (int): Size of the axis</p> Source code in <code>src/fft_analysator/analysis/signal_processing.py</code> <pre><code>def create_correlation_axis(self, N):\n    \"\"\"\n    The create_correlation_axis function creates the x-Axis for the correlation function\n    Args:\n        N (int): Size of the axis\n    \"\"\"\n\n    block_size_factor = self.data_callback.source.numsamples / self.block_size\n    if N % 2 == 0:\n        tau = np.arange(-N//2,N//2-1) * 4 * block_size_factor / self.abtastrate\n    else:  \n        tau = np.arange(-N//2,N//2) * 4 * block_size_factor / self.abtastrate\n\n    return tau\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.signal_processing.Signal_Process.create_frequency_axis","title":"create_frequency_axis","text":"<pre><code>create_frequency_axis()\n</code></pre> <p>The create_frequency_axis function creates the x-Axis for the frequency function</p> Source code in <code>src/fft_analysator/analysis/signal_processing.py</code> <pre><code>def create_frequency_axis(self):\n    \"\"\"\n    The create_frequency_axis function creates the x-Axis for the frequency function\n    \"\"\"\n\n    return self.powerspectra.fftfreq()\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.signal_processing.Signal_Process.create_time_axis","title":"create_time_axis","text":"<pre><code>create_time_axis(N)\n</code></pre> <p>The create_time_axis function creates a time axis for the x-Axis Args:     N (int): Size of the axis</p> Source code in <code>src/fft_analysator/analysis/signal_processing.py</code> <pre><code>def create_time_axis(self,N):\n    \"\"\"\n    The create_time_axis function creates a time axis for the x-Axis\n    Args:\n        N (int): Size of the axis\n    \"\"\"\n\n    time_axis = np.arange(N) / self.abtastrate\n    return time_axis\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.signal_processing.Signal_Process.csm","title":"csm","text":"<pre><code>csm(csm_dB=False)\n</code></pre> <p>The csm function calculates the csm (Cross Spectral Matrix) of Acoular for the valid signals. It returns a three-dimensional array with size (number of frequencies,2,2) where [:, signal1, signal2] is the Cross spectral density between signal1 and signal2.</p> <p>Parameters:</p> Name Type Description Default <code>window</code> <code>string</code> <p>window function for the fourier transformation: Allowed options: 'Rectangular','Hanning',</p> required <code>block_size</code> <code>int</code> <p>Length of data block. Allowed values: 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536</p> required <code>overlap</code> <code>string</code> <p>Overlap percentage between two blocks for the Welch-Method. Allowed options: 'None','50%',</p> required <code>csm_db</code> <code>boolean</code> <p>Return the array in dB values.</p> required Source code in <code>src/fft_analysator/analysis/signal_processing.py</code> <pre><code>def csm(self,csm_dB=False):\n    \"\"\"\n    The csm function calculates the csm (Cross Spectral Matrix) of Acoular for the valid signals. It returns a\n    three-dimensional array with size (number of frequencies,2,2) where [:, signal1, signal2] is the\n    Cross spectral density between signal1 and signal2.\n\n    Args:\n        window (string): window function for the fourier transformation: Allowed options: 'Rectangular','Hanning',\n        'Hamming', 'Bartlett', 'Blackman'\n        block_size (int): Length of data block. Allowed values: 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536\n        overlap (string): Overlap percentage between two blocks for the Welch-Method. Allowed options: 'None','50%',\n        '75%','87.5%'\n        csm_db (boolean): Return the array in dB values.\n\n    \"\"\"\n\n    if csm_dB:\n        self.current_data = 10*np.log10(self.powerspectra.csm)\n        return self.current_data\n    else:\n        self.current_data = self.powerspectra.csm\n        return self.current_data\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.signal_processing.Signal_Process.frequency_response","title":"frequency_response","text":"<pre><code>frequency_response(frq_rsp_dB=True)\n</code></pre> <p>The frequency_response function calculates the frequency response between the input and output signal. It uses the H1 estimator H1 = Gxy / Gxx, where Gxy is the Cross Spectral density between signal x and signal y and Gxx is the Power Spectral Density of signal x.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>boolean</code> <p>Return the array ian dB values.</p> required Source code in <code>src/fft_analysator/analysis/signal_processing.py</code> <pre><code>def frequency_response(self, frq_rsp_dB=True):\n    \"\"\"\n    The frequency_response function calculates the frequency response between the input and output signal.\n    It uses the H1 estimator H1 = Gxy / Gxx, where Gxy is the Cross Spectral density between signal x and signal y\n    and Gxx is the Power Spectral Density of signal x.\n\n    Args:      \n        db (boolean): Return the array ian dB values.\n    \"\"\"\n    csm_matrix = self.csm()\n\n    if self.input_channel == self.output_channel:\n        H = np.divide(csm_matrix[:, 0, 0].real, csm_matrix[:, 0, 0].real, out=np.zeros_like(csm_matrix[:, 0, 0].real), where=(np.abs(csm_matrix[:, 0, 0].real) &gt; 1e-10))\n    else:\n        H = np.divide(csm_matrix[:, 0, 1], csm_matrix[:, 0, 0].real, out=np.zeros_like(csm_matrix[:, 0, 1]), where=(np.abs(csm_matrix[:, 0, 1]) &gt; 1e-10))\n\n    if frq_rsp_dB:\n        # return SPL(f) based on H1 estimator\n        self.amplitude_response_data = 20*np.log10(abs(np.squeeze(H)/self.p0))\n    else:\n        # absoulte value of H1 estimator\n        self.amplitude_response_data = np.abs(np.squeeze(H))\n\n    return self.amplitude_response_data\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.signal_processing.Signal_Process.impuls_response","title":"impuls_response","text":"<pre><code>impuls_response(imp_dB=False)\n</code></pre> <p>The impulse_response function calculates the impulse response between the input and output signal. It uses the H1 estimator H1 = Gxy / Gxx, where Gxy is the Spectral density between signal x and signal y and Gxx is the Power Spectral Density of signal x.</p> <p>Parameters:</p> Name Type Description Default <code>imp_dB</code> <code>boolean</code> <p>Return the array in dB values.</p> <code>False</code> Source code in <code>src/fft_analysator/analysis/signal_processing.py</code> <pre><code>def impuls_response(self,imp_dB=False):\n    \"\"\"\n    The impulse_response function calculates the impulse response between the input and output signal.\n    It uses the H1 estimator H1 = Gxy / Gxx, where Gxy is the Spectral density between signal x and signal y\n    and Gxx is the Power Spectral Density of signal x.\n\n    Args:\n        imp_dB (boolean): Return the array in dB values.\n    \"\"\"\n    csm_matrix = self.csm()\n    if self.input_channel == self.output_channel:\n        H = np.divide(csm_matrix[:, 0, 0].real, csm_matrix[:, 0, 0].real, out=np.zeros_like(csm_matrix[:, 0, 0].real), where=(np.abs(csm_matrix[:, 0, 0].real) &gt; 1e-10))\n    else:\n        H = np.divide(csm_matrix[:, 0, 1], csm_matrix[:, 0, 0].real, out=np.zeros_like(csm_matrix[:, 0, 1]), where=(np.abs(csm_matrix[:, 0, 1]) &gt; 1e-10))\n\n    N = len(csm_matrix[:, 0, 0])\n    self.impulse_response_data = np.fft.irfft(H, n=N)\n\n    if imp_dB:\n        if self.input_channel != self.output_channel:\n            self.impulse_response_data = 20*np.log10(abs(self.impulse_response_data)/self.p0)\n        else:\n            self.impulse_response_data = np.ones(N) \n            self.impulse_response_data = 20*np.log10(abs(self.impulse_response_data)/self.p0)\n    else:\n        self.impulse_response_data = self.impulse_response_data\n\n    return self.impulse_response_data\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.signal_processing.Signal_Process.invalid_channels","title":"invalid_channels","text":"<pre><code>invalid_channels(valid_channels)\n</code></pre> <p>The invalid_channels function fills the invalid_channel_list with two valid channels chosen by the user. Args:     valid_channels (list): Contains the two selected channels chosen by the user.</p> Source code in <code>src/fft_analysator/analysis/signal_processing.py</code> <pre><code>def invalid_channels(self, valid_channels):\n    \"\"\"\n    The invalid_channels function fills the invalid_channel_list with two valid channels chosen by the user.\n    Args:\n        valid_channels (list): Contains the two selected channels chosen by the user.\n    \"\"\"\n\n    self.invalid_channel_list = [k for k in range(self.numchannels_total) if k not in valid_channels]\n    self.source.invalid_channels = self.invalid_channel_list\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.signal_processing.Signal_Process.phase_response","title":"phase_response","text":"<pre><code>phase_response(deg=True)\n</code></pre> <p>The phase_response function calculates the phase response between the input and output signal. It uses the H1 estimator H1 = Gxy / Gxx, where Gxy is the Cross Spectral Density between signal x and signal y and Gxx is the Power Spectral Density of signal x.</p> <p>Parameters:</p> Name Type Description Default <code>deg</code> <code>boolean</code> <p>Return the array in degrees</p> <code>True</code> Source code in <code>src/fft_analysator/analysis/signal_processing.py</code> <pre><code>def phase_response(self, deg=True):\n    \"\"\"\n    The phase_response function calculates the phase response between the input and output signal.\n    It uses the H1 estimator H1 = Gxy / Gxx, where Gxy is the Cross Spectral Density between signal x and signal y\n    and Gxx is the Power Spectral Density of signal x.\n\n    Args:  \n        deg (boolean): Return the array in degrees\n    \"\"\"\n    csm_matrix = self.csm()\n\n    if self.input_channel == self.output_channel:\n        H = np.divide(csm_matrix[:, 0, 0].real, csm_matrix[:, 0, 0].real, out=np.zeros_like(csm_matrix[:, 0, 0].real), where=(np.abs(csm_matrix[:, 0, 0].real) &gt; 1e0))\n    else:\n        H = np.divide(csm_matrix[:, 0, 1], csm_matrix[:, 0, 0].real, out=np.zeros_like(csm_matrix[:, 0, 1]), where=(np.abs(csm_matrix[:, 0, 1]) &gt; 1e-10))\n\n    phase = np.angle(H,deg=deg)\n    self.phase_response_data = phase\n\n    return self.phase_response_data\n</code></pre>"},{"location":"dev_frontend_documentation/","title":"Overview","text":"<p>The gui consists of different parts:</p> <ul> <li>The components, which are mostly widgets provided by panel.</li> <li>The main view and sidebar, which have various update functions for the widget and plots.</li> <li>The app controller, which has several event handlers that update on value change of the widgets that are watched with panel, usually in the sidebar class.</li> </ul>"},{"location":"frontend_components/","title":"Components","text":""},{"location":"frontend_components/#components","title":"Components","text":""},{"location":"frontend_components/#accordion","title":"Accordion","text":""},{"location":"frontend_components/#fft_analysator.gui.components.accordion","title":"accordion","text":""},{"location":"frontend_components/#fft_analysator.gui.components.accordion.Accordion","title":"Accordion","text":"<pre><code>Accordion()\n</code></pre> <p>A class representing an accordion component.</p> <p>The Accordion class is used to create an accordion component with various sub-components such as file input, color pickers, switches, menus, and sliders.</p> <p>Attributes:</p> Name Type Description <code>file_input</code> <code>FileInputComponent</code> <p>The file input component.</p> <code>color_picker_ch1</code> <code>Colorpicker</code> <p>The color picker for channel 1.</p> <code>color_picker_ch2</code> <code>Colorpicker</code> <p>The color picker for channel 2.</p> <code>color_picker_result</code> <code>Colorpicker</code> <p>The color picker for the result.</p> <code>stretching_switch</code> <code>Switch</code> <p>The switch for stretching.</p> <code>calculation_selector</code> <code>CalculationSelector</code> <p>The selector for calculations.</p> <code>selector</code> <code>Selector</code> <p>The selector component.</p> <code>data_selector</code> <code>DataSelector</code> <p>The data selector component.</p> <code>int_slider</code> <code>IntSlider</code> <p>The integer slider component.</p> <code>gen_nav</code> <code>GeneratorNavigator</code> <p>The generator navigator component.</p> <code>blocksize_selector</code> <code>BlocksizeSelector</code> <p>The blocksize selector component.</p> <code>channel_selector_input</code> <code>ChannelSelector</code> <p>The channel selector for input.</p> <code>channel_selector_output</code> <code>ChannelSelector</code> <p>The channel selector for output.</p> <code>window_selector</code> <code>WindowSelector</code> <p>The selector for the windows.</p> <code>overlap_selectgor</code> <code>OverlapSelector</code> <p>The selector for the overlaps.</p> <code>accordion</code> <code>Accordion</code> <p>The accordion component.</p> Source code in <code>src/fft_analysator/gui/components/accordion.py</code> <pre><code>def __init__(self):\n    self.file_input = FileInputComponent()\n    self.color_picker_ch1 = Colorpicker()\n    self.color_picker_ch2 = Colorpicker()\n    self.color_picker_result = Colorpicker()\n    self.method_selector = MethodSelector()\n    self.selector = Selector()\n    self.data_selector = DataSelector()\n    self.int_slider= IntSlider()\n    self.gen_nav = GeneratorNavigator(self.int_slider)\n    self.gen_nav = GeneratorNavigator(self.int_slider)\n    self.blocksize_selector = BlocksizeSelector()\n    self.channel_selector_input = ChannelSelector()\n    self.channel_selector_output = ChannelSelector()\n    self.window_selector = WindowSelector()\n    self.overlap_selector = OverlapSelector()\n    self.file_exporter = FileExporter()\n    self.exporter_selector = ExporterSelector()\n    self.toggle_group = ToggleGroup()\n    self.toggle_x_axis = ToggleXAxis()\n    self.toggle_y_axis = ToggleYAxis()\n    self.accordion = pn.Accordion\n\n    # Set default colors\n    self.color_picker_ch1.component.value = '#D23232' # Red for channel 1\n    self.color_picker_ch2.component.value = '#1D1DB9'  # Blue for channel 2\n    self.color_picker_result.component.value = '#CB8710'  # Green for result\n\n    # Initially hide the color picker\n    self.color_picker_ch1.component.visible = False\n    self.color_picker_ch2.component.visible = False\n    self.color_picker_result.component.visible = False\n\n    self._component = self.accordion(('Upload', pn.Column(pn.Row(self.file_input.component, self.data_selector.component), self.selector.component, self.blocksize_selector.component)),\n                                      ('Plot', pn.Column(pn.Row(self.channel_selector_input.component, self.channel_selector_output.component),\n                                                        pn.Row(self.color_picker_ch1.component,self.color_picker_ch2.component,self.color_picker_result.component),\n                                                        pn.layout.Divider(margin=(5, 0, 5, 0)),\n                                                        #self.int_slider.component,\n                                                        self.gen_nav.component,\n                                                        self.toggle_group.component,\n                                                        pn.Row(self.toggle_x_axis.component, self.toggle_y_axis.component)\n                                                        )),\n                                        ('Calculation', pn.Column(pn.Row(self.window_selector.component,\n                                                                        self.overlap_selector.component),\n                                                                        self.method_selector.component)\n                                         ),\n                                        ('Export', pn.Column(self.exporter_selector.component,self.file_exporter.component)),\n                                        sizing_mode='stretch_width')\n</code></pre>"},{"location":"frontend_components/#fft_analysator.gui.components.accordion.Accordion.component","title":"component  <code>property</code>","text":"<pre><code>component\n</code></pre> <p>Get the accordion component.</p> <p>Returns:</p> Type Description <p>pn.Accordion: The accordion component.</p>"},{"location":"frontend_components/#blocksize-selector","title":"Blocksize Selector","text":""},{"location":"frontend_components/#fft_analysator.gui.components.blocksize_selector","title":"blocksize_selector","text":""},{"location":"frontend_components/#fft_analysator.gui.components.blocksize_selector.BlocksizeSelector","title":"BlocksizeSelector","text":"<pre><code>BlocksizeSelector()\n</code></pre> <p>A class representing a block size selector.</p> <p>Attributes:</p> Name Type Description <code>blocksize_selector</code> <code>Select</code> <p>The block size selector widget.</p> <code>sizes</code> <code>list</code> <p>A list of available block sizes.</p> <code>_component</code> <code>Select</code> <p>The internal block size selector component.</p> Source code in <code>src/fft_analysator/gui/components/blocksize_selector.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    The block size selector is initialized as a panel Select widget with specific parameters.\n    \"\"\"\n    self.blocksize_selector = pn.widgets.Select\n    self.sizes = [128, 256, 512, 1024, 2048, 8192, 16384, 32768, 65536]\n    self._component = self.blocksize_selector(name='Select Blocksize', options=self.sizes, value=1024)\n</code></pre>"},{"location":"frontend_components/#fft_analysator.gui.components.blocksize_selector.BlocksizeSelector.component","title":"component  <code>property</code>","text":"<pre><code>component\n</code></pre> <p>Get the block size selector component.</p> <p>Returns:</p> Type Description <p>pn.widgets.Select: The block size selector component.</p>"},{"location":"frontend_components/#channel-selector","title":"Channel Selector","text":""},{"location":"frontend_components/#fft_analysator.gui.components.channel_selector","title":"channel_selector","text":""},{"location":"frontend_components/#fft_analysator.gui.components.channel_selector.ChannelSelector","title":"ChannelSelector","text":"<pre><code>ChannelSelector()\n</code></pre> <p>A class used to represent a Channel Selector widget.</p>"},{"location":"frontend_components/#fft_analysator.gui.components.channel_selector.ChannelSelector--attributes","title":"Attributes","text":"<p>selector : object     An instance of the panel Select widget. options : list     A list of options for the selector widget. Initially empty. _component : object     The panel Select widget with specific parameters.</p> Source code in <code>src/fft_analysator/gui/components/channel_selector.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    The selector attribute is initialized as a panel Select widget.\n    \"\"\"\n    self.selector = pn.widgets.Select\n    self.options = []\n    self._component = self.selector(name='No data chosen!', options=self.options, width=135, margin=(10,15),\n                                    disabled=True)\n</code></pre>"},{"location":"frontend_components/#fft_analysator.gui.components.channel_selector.ChannelSelector.component","title":"component  <code>property</code>","text":"<pre><code>component\n</code></pre> <p>Gets the stored widget.</p>"},{"location":"frontend_components/#fft_analysator.gui.components.channel_selector.ChannelSelector.component--returns","title":"Returns","text":"<p>object     The stored widget.</p>"},{"location":"frontend_components/#color-picker","title":"Color Picker","text":""},{"location":"frontend_components/#fft_analysator.gui.components.color_picker","title":"color_picker","text":""},{"location":"frontend_components/#fft_analysator.gui.components.color_picker.Colorpicker","title":"Colorpicker","text":"<pre><code>Colorpicker()\n</code></pre> <p>A class used to represent a Color Picker widget.</p>"},{"location":"frontend_components/#fft_analysator.gui.components.color_picker.Colorpicker--attributes","title":"Attributes","text":"<p>color_picker : object     An instance of the panel ColorPicker widget. _component : object     The panel ColorPicker widget with specific parameters.</p> Source code in <code>src/fft_analysator/gui/components/color_picker.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    The color picker is initialized as a panel ColorPicker widget with specific parameters.\n    \"\"\"\n    self.color_picker = pn.widgets.ColorPicker\n    self._component = self.color_picker(name='', value='#FF0000', margin=(10, 30), visible=False)\n</code></pre>"},{"location":"frontend_components/#fft_analysator.gui.components.color_picker.Colorpicker.component","title":"component  <code>property</code>","text":"<pre><code>component\n</code></pre> <p>Gets the stored widget.</p>"},{"location":"frontend_components/#fft_analysator.gui.components.color_picker.Colorpicker.component--returns","title":"Returns","text":"<p>object     The stored widget.</p>"},{"location":"frontend_components/#data-selector","title":"Data Selector","text":""},{"location":"frontend_components/#fft_analysator.gui.components.data_selector","title":"data_selector","text":""},{"location":"frontend_components/#fft_analysator.gui.components.data_selector.DataSelector","title":"DataSelector","text":"<pre><code>DataSelector()\n</code></pre> <p>A class used to represent a Data Selector widget.</p> <p>This class encapsulates a panel Select widget and provides an interface for populating it with options and retrieving the selected option.</p>"},{"location":"frontend_components/#fft_analysator.gui.components.data_selector.DataSelector--attributes","title":"Attributes","text":"<p>selector : object     An instance of the panel Select widget. options : list     A list of options for the selector widget. Initially empty. _component : object     The panel Select widget with specific parameters.</p>"},{"location":"frontend_components/#fft_analysator.gui.components.data_selector.DataSelector--methods","title":"Methods","text":"<p>component()     Gets the stored widget.</p> <p>The selector attribute is initialized as a panel Select widget. The options attribute is initialized as an empty list. The _component attribute is initialized as a panel Select widget with specific parameters.</p> Source code in <code>src/fft_analysator/gui/components/data_selector.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Constructs all the necessary attributes for the DataSelector object.\n\n    The selector attribute is initialized as a panel Select widget.\n    The options attribute is initialized as an empty list.\n    The _component attribute is initialized as a panel Select widget with specific parameters.\n    \"\"\"\n    self.selector = pn.widgets.Select\n    self.options = []\n    self._component = self.selector(name='', options=self.options, size=len(self.options)+2,\n                                    margin=(20, 0, 0, 20), height=30, width=200)\n</code></pre>"},{"location":"frontend_components/#fft_analysator.gui.components.data_selector.DataSelector.component","title":"component  <code>property</code>","text":"<pre><code>component\n</code></pre> <p>Gets the stored widget.</p>"},{"location":"frontend_components/#fft_analysator.gui.components.data_selector.DataSelector.component--returns","title":"Returns","text":"<p>object     The stored widget.</p>"},{"location":"frontend_components/#file-input-tkinter","title":"File Input Tkinter","text":""},{"location":"frontend_components/#fft_analysator.gui.components.file_input_tkinter","title":"file_input_tkinter","text":""},{"location":"frontend_components/#fft_analysator.gui.components.file_input_tkinter.FileInputComponent","title":"FileInputComponent","text":"<pre><code>FileInputComponent()\n</code></pre> <p>A class used to represent a File Input Component.</p>"},{"location":"frontend_components/#fft_analysator.gui.components.file_input_tkinter.FileInputComponent--attributes","title":"Attributes","text":"<p>file_input_button : object     An instance of the panel Button widget. _component : object     The panel Button widget with specific parameters. file_paths : str     The paths of the selected files. Initially None.</p>"},{"location":"frontend_components/#fft_analysator.gui.components.file_input_tkinter.FileInputComponent--methods","title":"Methods","text":"<p>select_files(event)     Opens a file dialog to select files. component()     Gets the stored widget.</p> <p>The file_input_button attribute is initialized as a panel Button widget. The _component attribute is initialized as a panel Button widget with specific parameters. The file_paths attribute is initialized as None.</p> Source code in <code>src/fft_analysator/gui/components/file_input_tkinter.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Constructs all the necessary attributes for the FileInputComponent object.\n\n    The file_input_button attribute is initialized as a panel Button widget.\n    The _component attribute is initialized as a panel Button widget with specific parameters.\n    The file_paths attribute is initialized as None.\n    \"\"\"\n    self.file_input_button = pn.widgets.Button\n    self._component = self.file_input_button(name=\"Load file\", margin=(20, 0, 10, 10))\n    self.file_paths = None\n    pn.bind(self.select_files, self._component, watch=True)\n</code></pre>"},{"location":"frontend_components/#fft_analysator.gui.components.file_input_tkinter.FileInputComponent.component","title":"component  <code>property</code>","text":"<pre><code>component\n</code></pre> <p>Gets the stored widget.</p>"},{"location":"frontend_components/#fft_analysator.gui.components.file_input_tkinter.FileInputComponent.component--returns","title":"Returns","text":"<p>object     The stored widget.</p>"},{"location":"frontend_components/#fft_analysator.gui.components.file_input_tkinter.FileInputComponent.select_files","title":"select_files","text":"<pre><code>select_files(event)\n</code></pre> <p>Opens a file dialog to select files.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>object</code> <p>The event object passed by the panel Button widget.</p> required Source code in <code>src/fft_analysator/gui/components/file_input_tkinter.py</code> <pre><code>def select_files(self, event):\n    \"\"\"\n    Opens a file dialog to select files.\n\n    Args:\n        event (object): The event object passed by the panel Button widget.\n    \"\"\"\n    root = Tk()\n    root.withdraw()\n    root.call('wm', 'attributes', '.', '-topmost', True)\n    files = filedialog.askopenfilename(\n        multiple=False,\n        filetypes=[(\"HDF5 files\", \"*.h5\")],  # Nur .h5 Dateien erlauben\n        initialdir=os.getcwd()  # Starten im aktuellen Verzeichnis\n    )\n    if files:\n        self.file_paths = files\n    else:\n        self.file_paths = None\n    root.destroy()\n</code></pre>"},{"location":"frontend_components/#generator-navigator","title":"Generator Navigator","text":""},{"location":"frontend_components/#fft_analysator.gui.components.generator_navigator","title":"generator_navigator","text":""},{"location":"frontend_components/#fft_analysator.gui.components.generator_navigator.GeneratorNavigator","title":"GeneratorNavigator","text":"<pre><code>GeneratorNavigator(int_slider_callback)\n</code></pre> <p>A class used to represent a Generator Navigator.</p>"},{"location":"frontend_components/#fft_analysator.gui.components.generator_navigator.GeneratorNavigator--attributes","title":"Attributes","text":"<p>button_back : object     An instance of the panel Button widget for navigating backwards. button_forward : object     An instance of the panel Button widget for navigating forwards. reset_button : object     An instance of the panel Button widget for resetting. index_box : object     An instance of the panel IntInput widget for inputting index. goto_button : object     An instance of the panel Button widget for going to a specific index. _component : object     The panel Row widget with specific parameters. int_slider_callback : object     The callback function for the integer slider.</p>"},{"location":"frontend_components/#fft_analysator.gui.components.generator_navigator.GeneratorNavigator--methods","title":"Methods","text":"<p>int_slider_next(event)     Increments the value of the integer slider. int_slider_previous(event)     Decrements the value of the integer slider. int_slider_reset(event)     Resets the value of the integer slider. int_slider_goto(event)     Sets the value of the integer slider to the value of the index box. component()     Gets the stored widget.</p> <p>The button_back, button_forward, reset_button, index_box, and goto_button attributes are initialized as panel Button widgets. The _component attribute is initialized as a panel Row widget with specific parameters. The int_slider_callback attribute is set to the provided callback function.</p> Source code in <code>src/fft_analysator/gui/components/generator_navigator.py</code> <pre><code>def __init__(self, int_slider_callback):\n    \"\"\"\n    Constructs all the necessary attributes for the GeneratorNavigator object.\n\n    The button_back, button_forward, reset_button, index_box, and goto_button attributes are initialized as panel Button widgets.\n    The _component attribute is initialized as a panel Row widget with specific parameters.\n    The int_slider_callback attribute is set to the provided callback function.\n    \"\"\"\n    self.button_back = pn.widgets.Button(name='\\u25c0', button_type='default', margin=(10, 5, 5, 5), disabled=True)\n    self.button_forward = pn.widgets.Button(name='\\u25b6', button_type='default', margin=(10, 5, 5, 5), disabled=True)\n    self.reset_button = pn.widgets.Button(name='\\u21ba', button_type='default', margin=(10, 5, 5, 5), disabled=True)\n    self.index_box = pn.widgets.IntInput(name='Index:', value=0, margin=(-10, 20, 0, 10), disabled=True, width=80)\n    self.goto_button = pn.widgets.Button(name='Go', button_type='default', margin=(10, 5, 5, 5), disabled=True)\n    self._component = pn.Row(self.goto_button, self.index_box, self.button_back, self.reset_button, self.button_forward,\n                             margin=(5, 5, 10, 5))\n\n    self.int_slider_callback = int_slider_callback\n\n    pn.bind(self.int_slider_next, self.button_forward, watch=True)\n    pn.bind(self.int_slider_previous, self.button_back, watch=True)\n    pn.bind(self.int_slider_reset, self.reset_button, watch=True)\n    pn.bind(self.int_slider_goto, self.goto_button, watch=True)\n</code></pre>"},{"location":"frontend_components/#fft_analysator.gui.components.generator_navigator.GeneratorNavigator.component","title":"component  <code>property</code>","text":"<pre><code>component\n</code></pre> <p>Gets the stored widget.</p>"},{"location":"frontend_components/#fft_analysator.gui.components.generator_navigator.GeneratorNavigator.component--returns","title":"Returns","text":"<p>object     The stored widget.</p>"},{"location":"frontend_components/#fft_analysator.gui.components.generator_navigator.GeneratorNavigator.int_slider_goto","title":"int_slider_goto","text":"<pre><code>int_slider_goto(event)\n</code></pre> <p>Sets the value of the integer slider to the value of the index box.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>object</code> <p>The event object passed by the panel Button widget.</p> required Source code in <code>src/fft_analysator/gui/components/generator_navigator.py</code> <pre><code>def int_slider_goto(self, event):\n    \"\"\"\n    Sets the value of the integer slider to the value of the index box.\n\n    Args:\n        event (object): The event object passed by the panel Button widget.\n    \"\"\"\n    if (self.index_box.value &lt;= self.int_slider_callback.component.end\n        and self.index_box.value &gt;= self.int_slider_callback.component.start):\n        self.int_slider_callback.component.value = self.index_box.value\n</code></pre>"},{"location":"frontend_components/#fft_analysator.gui.components.generator_navigator.GeneratorNavigator.int_slider_next","title":"int_slider_next","text":"<pre><code>int_slider_next(event)\n</code></pre> <p>Increments the value of the integer slider.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>object</code> <p>The event object passed by the panel Button widget.</p> required Source code in <code>src/fft_analysator/gui/components/generator_navigator.py</code> <pre><code>def int_slider_next(self, event):\n    \"\"\"\n    Increments the value of the integer slider.\n\n    Args:\n        event (object): The event object passed by the panel Button widget.\n    \"\"\"\n    if (self.int_slider_callback.component.value &lt; self.int_slider_callback.component.end):\n        self.int_slider_callback.component.value += 1\n</code></pre>"},{"location":"frontend_components/#fft_analysator.gui.components.generator_navigator.GeneratorNavigator.int_slider_previous","title":"int_slider_previous","text":"<pre><code>int_slider_previous(event)\n</code></pre> <p>Decrements the value of the integer slider.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>object</code> <p>The event object passed by the panel Button widget.</p> required Source code in <code>src/fft_analysator/gui/components/generator_navigator.py</code> <pre><code>def int_slider_previous(self, event):\n    \"\"\"\n    Decrements the value of the integer slider.\n\n    Args:\n        event (object): The event object passed by the panel Button widget.\n    \"\"\"\n    if (self.int_slider_callback.component.value &gt; self.int_slider_callback.component.start):\n        self.int_slider_callback.component.value -= 1\n</code></pre>"},{"location":"frontend_components/#fft_analysator.gui.components.generator_navigator.GeneratorNavigator.int_slider_reset","title":"int_slider_reset","text":"<pre><code>int_slider_reset(event)\n</code></pre> <p>Resets the value of the integer slider.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>object</code> <p>The event object passed by the panel Button widget.</p> required Source code in <code>src/fft_analysator/gui/components/generator_navigator.py</code> <pre><code>def int_slider_reset(self, event):\n    \"\"\"\n    Resets the value of the integer slider.\n\n    Args:\n        event (object): The event object passed by the panel Button widget.\n    \"\"\"\n    if self.int_slider_callback:\n        self.int_slider_callback.component.value = 0\n</code></pre>"},{"location":"frontend_components/#integer-slider","title":"Integer Slider","text":""},{"location":"frontend_components/#fft_analysator.gui.components.int_slider","title":"int_slider","text":""},{"location":"frontend_components/#fft_analysator.gui.components.int_slider.IntSlider","title":"IntSlider","text":"<pre><code>IntSlider()\n</code></pre> <p>A helper class used to represent a helper Integer Slider widget to store the logic for the generator navigation buttons.</p>"},{"location":"frontend_components/#fft_analysator.gui.components.int_slider.IntSlider--attributes","title":"Attributes","text":"<p>int_slider : object     An instance of the panel IntSlider widget. _component : object     The panel IntSlider widget with specific parameters.</p>"},{"location":"frontend_components/#fft_analysator.gui.components.int_slider.IntSlider--methods","title":"Methods","text":"<p>component()     Gets the stored widget.</p> <p>The int_slider attribute is initialized as a panel IntSlider widget. The _component attribute is initialized as a panel IntSlider widget with specific parameters.</p> Source code in <code>src/fft_analysator/gui/components/int_slider.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Constructs all the necessary attributes for the IntSlider object.\n\n    The int_slider attribute is initialized as a panel IntSlider widget.\n    The _component attribute is initialized as a panel IntSlider widget with specific parameters.\n    \"\"\"\n    self.int_slider = pn.widgets.IntSlider\n    self._component = self.int_slider(name='Current Block', start=0, step=1, margin=(15, 20, 25, 20),\n    sizing_mode='stretch_width', disabled=True, align='start')\n</code></pre>"},{"location":"frontend_components/#fft_analysator.gui.components.int_slider.IntSlider.component","title":"component  <code>property</code>","text":"<pre><code>component\n</code></pre> <p>Gets the stored widget.</p>"},{"location":"frontend_components/#fft_analysator.gui.components.int_slider.IntSlider.component--returns","title":"Returns","text":"<p>object     The stored widget.</p>"},{"location":"frontend_components/#methode-selector","title":"Methode Selector","text":""},{"location":"frontend_components/#fft_analysator.gui.components.method_selector","title":"method_selector","text":""},{"location":"frontend_components/#fft_analysator.gui.components.method_selector.MethodSelector","title":"MethodSelector","text":"<pre><code>MethodSelector()\n</code></pre> <p>A class used to represent a Method Selector widget.</p>"},{"location":"frontend_components/#fft_analysator.gui.components.method_selector.MethodSelector--attributes","title":"Attributes","text":"<p>selector : object     An instance of the panel Select widget. options : list     A list of options for the selector widget. _component : object     The panel Select widget with specific parameters.</p>"},{"location":"frontend_components/#fft_analysator.gui.components.method_selector.MethodSelector--methods","title":"Methods","text":"<p>component()     Gets the stored widget.</p> <p>The selector attribute is initialized as a panel Select widget. The options attribute is initialized with a list of analysis methods. The _component attribute is initialized as a panel Select widget with specific parameters.</p> Source code in <code>src/fft_analysator/gui/components/method_selector.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Constructs all the necessary attributes for the MethodSelector object.\n\n    The selector attribute is initialized as a panel Select widget.\n    The options attribute is initialized with a list of analysis methods.\n    The _component attribute is initialized as a panel Select widget with specific parameters.\n    \"\"\"\n    self.selector = pn.widgets.Select\n    self.options = [\"No Analysis Function\", \"Auto Spectral Density - Input\", \"Auto Spectral Density - Output\",\n                    \"Cross Spectral Density\", \"Coherence\",\"Auto Correlation - Input\", \"Auto Correlation - Output\",\n                    \"Cross Correlation\", \"Impulse Response\", \"Amplitude Response\", \"Phase Response\"]\n    self._component = self.selector(name='Choose analysis and saving method:', options=self.options, width=300,\n                                    value='No Analysis Function', disabled=True)\n</code></pre>"},{"location":"frontend_components/#fft_analysator.gui.components.method_selector.MethodSelector.component","title":"component  <code>property</code>","text":"<pre><code>component\n</code></pre> <p>Gets the stored widget.</p>"},{"location":"frontend_components/#fft_analysator.gui.components.method_selector.MethodSelector.component--returns","title":"Returns","text":"<p>object     The stored widget.</p>"},{"location":"frontend_components/#overlap-selector","title":"Overlap Selector","text":""},{"location":"frontend_components/#fft_analysator.gui.components.overlap_selector","title":"overlap_selector","text":""},{"location":"frontend_components/#fft_analysator.gui.components.overlap_selector.OverlapSelector","title":"OverlapSelector","text":"<pre><code>OverlapSelector()\n</code></pre> <p>A class used to represent an Overlap Selector widget.</p>"},{"location":"frontend_components/#fft_analysator.gui.components.overlap_selector.OverlapSelector--attributes","title":"Attributes","text":"<p>selector : object     An instance of the panel Select widget. options : list     A list of options for the selector widget. _component : object     The panel Select widget with specific parameters.</p>"},{"location":"frontend_components/#fft_analysator.gui.components.overlap_selector.OverlapSelector--methods","title":"Methods","text":"<p>component()     Gets the stored widget.</p> <p>The selector attribute is initialized as a panel Select widget. The options attribute is initialized with a list of overlap options. The _component attribute is initialized as a panel Select widget with specific parameters.</p> Source code in <code>src/fft_analysator/gui/components/overlap_selector.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Constructs all the necessary attributes for the OverlapSelector object.\n\n    The selector attribute is initialized as a panel Select widget.\n    The options attribute is initialized with a list of overlap options.\n    The _component attribute is initialized as a panel Select widget with specific parameters.\n    \"\"\"\n    self.selector = pn.widgets.Select\n    self.options = ['None', '50%', '75%', '87.5%']\n    self._component = self.selector(name='Choose overlap:', options=self.options, width=140, value='50%',\n                                    disabled=True)\n</code></pre>"},{"location":"frontend_components/#fft_analysator.gui.components.overlap_selector.OverlapSelector.component","title":"component  <code>property</code>","text":"<pre><code>component\n</code></pre> <p>Gets the stored widget.</p>"},{"location":"frontend_components/#fft_analysator.gui.components.overlap_selector.OverlapSelector.component--returns","title":"Returns","text":"<p>object     The stored widget.</p>"},{"location":"frontend_components/#selector","title":"Selector","text":""},{"location":"frontend_components/#fft_analysator.gui.components.selector","title":"selector","text":""},{"location":"frontend_components/#fft_analysator.gui.components.selector.Selector","title":"Selector","text":"<pre><code>Selector()\n</code></pre> <p>A class used to represent a Selector widget.</p> <p>This class encapsulates a panel Select widget and provides an interface for populating it with options and retrieving the selected option.</p>"},{"location":"frontend_components/#fft_analysator.gui.components.selector.Selector--attributes","title":"Attributes","text":"<p>selector : object     An instance of the panel Select widget. options : list     A list of options for the selector widget. Initially empty. _component : object     The panel Select widget with specific parameters.</p>"},{"location":"frontend_components/#fft_analysator.gui.components.selector.Selector--methods","title":"Methods","text":"<p>component()     Gets the stored widget.</p> <p>The selector attribute is initialized as a panel Select widget. The options attribute is initialized as an empty list. The _component attribute is initialized as a panel Select widget with specific parameters.</p> Source code in <code>src/fft_analysator/gui/components/selector.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Constructs all the necessary attributes for the Selector object.\n\n    The selector attribute is initialized as a panel Select widget.\n    The options attribute is initialized as an empty list.\n    The _component attribute is initialized as a panel Select widget with specific parameters.\n    \"\"\"\n    self.selector = pn.widgets.Select\n    self.options = []\n    self._component = self.selector(name='Choose table:', options=self.options, size=len(self.options)+2)\n</code></pre>"},{"location":"frontend_components/#fft_analysator.gui.components.selector.Selector.component","title":"component  <code>property</code>","text":"<pre><code>component\n</code></pre> <p>Gets the stored widget.</p> <p>This method returns the panel Select widget stored in the _component attribute.</p>"},{"location":"frontend_components/#fft_analysator.gui.components.selector.Selector.component--returns","title":"Returns","text":"<p>object     The stored widget.</p>"},{"location":"frontend_components/#toggle-group","title":"Toggle Group","text":""},{"location":"frontend_components/#fft_analysator.gui.components.toggle_group","title":"toggle_group","text":""},{"location":"frontend_components/#fft_analysator.gui.components.toggle_group.ToggleGroup","title":"ToggleGroup","text":"<pre><code>ToggleGroup()\n</code></pre> <p>A class used to represent a ToggleGroup widget.</p> <p>This class encapsulates a panel ToggleGroup widget and provides an interface for populating it with options and retrieving the selected option.</p>"},{"location":"frontend_components/#fft_analysator.gui.components.toggle_group.ToggleGroup--attributes","title":"Attributes","text":"<p>selector : object     An instance of the panel Select widget. options : list     A list of options for the selector widget. Initially empty. _component : object     The panel Select widget with specific parameters.</p>"},{"location":"frontend_components/#fft_analysator.gui.components.toggle_group.ToggleGroup--methods","title":"Methods","text":"<p>component()     Gets the stored widget.</p> <p>The selector attribute is initialized as a panel Select widget. The options attribute is initialized as an empty list. The _component attribute is initialized as a panel Select widget with specific parameters.</p> Source code in <code>src/fft_analysator/gui/components/toggle_group.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Constructs all the necessary attributes for the Selector object.\n\n    The selector attribute is initialized as a panel Select widget.\n    The options attribute is initialized as an empty list.\n    The _component attribute is initialized as a panel Select widget with specific parameters.\n    \"\"\"\n    self.stretch = False\n    self.grid = False\n    self.log = False\n    self.db = False\n    self.toggle_group = pn.widgets.ToggleGroup\n    self.options = ['Stretch','dB','Grid']\n    self._component = self.toggle_group(name='Choose table:', options=self.options, width=300, disabled=True)\n</code></pre>"},{"location":"frontend_components/#fft_analysator.gui.components.toggle_group.ToggleGroup.component","title":"component  <code>property</code>","text":"<pre><code>component\n</code></pre> <p>Gets the stored widget.</p> <p>This method returns the panel Select widget stored in the _component attribute.</p>"},{"location":"frontend_components/#fft_analysator.gui.components.toggle_group.ToggleGroup.component--returns","title":"Returns","text":"<p>object     The stored widget.</p>"},{"location":"frontend_components/#tabs","title":"Tabs","text":""},{"location":"frontend_components/#fft_analysator.gui.components.tabs","title":"tabs","text":""},{"location":"frontend_components/#fft_analysator.gui.components.tabs.Tabs","title":"Tabs","text":"<pre><code>Tabs()\n</code></pre> <p>A class used to represent a Tabs widget.</p> <p>This class encapsulates a panel Tabs widget and provides an interface for interacting with it.</p>"},{"location":"frontend_components/#fft_analysator.gui.components.tabs.Tabs--attributes","title":"Attributes","text":"<p>tabs : object     An instance of the panel Tabs widget. str_signal_tab : str     The title of the signal tab. str_frequency_response_tab : str     The title of the frequency response tab. str_impulse_response_tab : str     The title of the impulse response tab. str_analysis_function_tab : str     The title of the analysis function tab. _component : object     The panel Tabs widget with specific parameters.</p>"},{"location":"frontend_components/#fft_analysator.gui.components.tabs.Tabs--methods","title":"Methods","text":"<p>component()     Gets the stored widget.</p> <p>The tabs attribute is initialized as a panel Tabs widget. The str_signal_tab, str_frequency_response_tab, str_impulse_response_tab, and str_analysis_function_tab attributes are initialized with specific string values. The _component attribute is initialized as a panel Tabs widget with specific parameters.</p> Source code in <code>src/fft_analysator/gui/components/tabs.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Constructs all the necessary attributes for the Tabs object.\n\n    The tabs attribute is initialized as a panel Tabs widget.\n    The str_signal_tab, str_frequency_response_tab, str_impulse_response_tab, and str_analysis_function_tab attributes are initialized with specific string values.\n    The _component attribute is initialized as a panel Tabs widget with specific parameters.\n    \"\"\"\n    self.tabs = pn.Tabs\n    self.str_signal_tab = \"Input/Output\"\n    self.str_frequency_response_tab = \"Frequency Response\"\n    self.str_impulse_response_tab = \"Impulse Response\"\n    self.str_analysis_function_tab = \"Analysis Functions\"\n    self._component = self.tabs(\n        (self.str_signal_tab, 'No data chosen!'),\n        (self.str_frequency_response_tab, 'No data chosen!'),\n        (self.str_impulse_response_tab, 'No data chosen!'),\n        (self.str_analysis_function_tab, 'No data chosen!'),\n        sizing_mode='stretch_width', dynamic=True)\n</code></pre>"},{"location":"frontend_components/#fft_analysator.gui.components.tabs.Tabs.component","title":"component  <code>property</code>","text":"<pre><code>component\n</code></pre> <p>Gets the stored widget.</p> <p>This method returns the panel Tabs widget stored in the _component attribute.</p>"},{"location":"frontend_components/#fft_analysator.gui.components.tabs.Tabs.component--returns","title":"Returns","text":"<p>object     The stored widget.</p>"},{"location":"frontend_components/#window-selector","title":"Window Selector","text":""},{"location":"frontend_components/#fft_analysator.gui.components.window_selector","title":"window_selector","text":""},{"location":"frontend_components/#fft_analysator.gui.components.window_selector.WindowSelector","title":"WindowSelector","text":"<pre><code>WindowSelector()\n</code></pre> <p>A class used to represent a Window Selector widget.</p> <p>This class encapsulates a panel Select widget and provides an interface for populating it with window options and retrieving the selected option.</p>"},{"location":"frontend_components/#fft_analysator.gui.components.window_selector.WindowSelector--attributes","title":"Attributes","text":"<p>selector : object     An instance of the panel Select widget. options : list     A list of options for the selector widget. _component : object     The panel Select widget with specific parameters.</p>"},{"location":"frontend_components/#fft_analysator.gui.components.window_selector.WindowSelector--methods","title":"Methods","text":"<p>component()     Gets the stored widget.</p> <p>The selector attribute is initialized as a panel Select widget. The options attribute is initialized with a list of window options. The _component attribute is initialized as a panel Select widget with specific parameters.</p> Source code in <code>src/fft_analysator/gui/components/window_selector.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Constructs all the necessary attributes for the WindowSelector object.\n\n    The selector attribute is initialized as a panel Select widget.\n    The options attribute is initialized with a list of window options.\n    The _component attribute is initialized as a panel Select widget with specific parameters.\n    \"\"\"\n    self.selector = pn.widgets.Select\n    self.options = ['Hanning', 'Rectangular', 'Hamming', 'Bartlett', 'Blackman']\n    self._component = self.selector(name='Choose window:', options=self.options, width=140, value='Hanning',\n                                    disabled=True)\n</code></pre>"},{"location":"frontend_components/#fft_analysator.gui.components.window_selector.WindowSelector.component","title":"component  <code>property</code>","text":"<pre><code>component\n</code></pre> <p>Gets the stored widget.</p> <p>This method returns the panel Select widget stored in the _component attribute.</p>"},{"location":"frontend_components/#fft_analysator.gui.components.window_selector.WindowSelector.component--returns","title":"Returns","text":"<p>object     The stored widget.</p>"},{"location":"frontend_controllers/","title":"Controllers","text":""},{"location":"frontend_controllers/#fft_analysator.gui.controllers.app_controller","title":"app_controller","text":""},{"location":"frontend_controllers/#fft_analysator.gui.controllers.app_controller.AppController","title":"AppController","text":"<pre><code>AppController()\n</code></pre> <p>A class used to control the application's logic.</p> <p>This class is responsible for handling user interactions and updating the application's state accordingly.</p>"},{"location":"frontend_controllers/#fft_analysator.gui.controllers.app_controller.AppController--attributes","title":"Attributes","text":"<p>main_view : object     An instance of the MainView class. current_method : str     The currently selected analysis method. sidebar : object     An instance of the Sidebar class. template_layout : object     A FastListTemplate instance for the application layout. file_paths : str     The paths to the data files.</p>"},{"location":"frontend_controllers/#fft_analysator.gui.controllers.app_controller.AppController--methods","title":"Methods","text":"<p>handle_fileupload_event()     Handles the file upload event. handle_sidebar_event()     Handles the sidebar event. handle_table_choose_event()     Handles the table choose event. handle_intslider_event()     Handles the intslider event. handle_blocksize_selector_event()     Handles the blocksize selector event. handle_update_analysis_event()     Handles the update analysis event.</p> <p>The main_view attribute is initialized as a MainView instance. The current_method attribute is initialized with a string value. The sidebar attribute is initialized as a Sidebar instance with specific event handlers. The template_layout attribute is initialized as a FastListTemplate instance with specific parameters. The file_paths attribute is initialized as None.</p> Source code in <code>src/fft_analysator/gui/controllers/app_controller.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Constructs all the necessary attributes for the AppController object.\n\n    The main_view attribute is initialized as a MainView instance.\n    The current_method attribute is initialized with a string value.\n    The sidebar attribute is initialized as a Sidebar instance with specific event handlers.\n    The template_layout attribute is initialized as a FastListTemplate instance with specific parameters.\n    The file_paths attribute is initialized as None.\n    \"\"\"\n    # Initialization of main and side views\n    self.main_view = MainView()\n    self.current_method = 'No Analysis Function'\n    self.sidebar = Sidebar(self.handle_fileupload_event, self.handle_sidebar_event, self.handle_table_choose_event,\n                            self.handle_intslider_event, self.handle_blocksize_selector_event, self.handle_update_analysis_event,\n                            self.handle_export_event, self.handle_method_event)\n\n    # Initialization of panel extensions and template\n    self.template_layout = pn.template.FastListTemplate(title=\"FFT-Analysator\",\n                                                        header_background=\"#E91E63\",\n                                                        accent_base_color=\"#E91E63\",\n                                                        theme=\"dark\",\n                                                        sidebar=self.sidebar.layout,\n                                                        main=self.main_view.layout\n                                                        )\n\n    # Initialization of data preprocessing and binary file\n    self.file_paths = None\n    self.preprocessing = None\n</code></pre>"},{"location":"frontend_controllers/#fft_analysator.gui.controllers.app_controller.AppController.handle_blocksize_selector_event","title":"handle_blocksize_selector_event","text":"<pre><code>handle_blocksize_selector_event(event)\n</code></pre> <p>Handles the blocksize selector event.</p> <p>This method is called when a blocksize selector event occurs.</p> Source code in <code>src/fft_analysator/gui/controllers/app_controller.py</code> <pre><code>def handle_blocksize_selector_event(self, event):\n    \"\"\"\n    Handles the blocksize selector event.\n\n    This method is called when a blocksize selector event occurs.\n    \"\"\"\n    if self.file_paths:\n        # reinitalize the preprocessing object with the new blocksize\n        self.preprocessing = pp.Preprocess(self.file_paths, self.sidebar.accordion.blocksize_selector.component.value)\n        self.signal_process = Signal_Process(channels=[], file_path=self.file_paths,\n                                            block_size=self.sidebar.accordion.blocksize_selector.component.value,\n                                            data_callback=self.preprocessing)\n\n        # update the sidebar components\n        self.sidebar.update_file_list()\n        self.sidebar.update_selector(self.preprocessing)\n        self.sidebar.update_channel_selector(self.preprocessing)\n        self.sidebar.update_intslider(self.preprocessing)\n        self.main_view.update_signal(\n            self.preprocessing,\n            self.signal_process,\n            [self.sidebar.accordion.channel_selector_input.component.value,\n            self.sidebar.accordion.channel_selector_output.component.value],\n            self.sidebar.accordion.toggle_group.stretch,\n            [self.sidebar.accordion.color_picker_ch1.component.value,\n            self.sidebar.accordion.color_picker_ch2.component.value,\n            self.sidebar.accordion.color_picker_result.component.value],\n            self.sidebar.accordion.window_selector.component.value,\n            self.sidebar.accordion.overlap_selector.component.value,\n            self.sidebar.accordion.toggle_group.grid,\n            self.sidebar.accordion.toggle_x_axis.x_log,\n            self.sidebar.accordion.toggle_y_axis.y_log,\n            self.sidebar.accordion.toggle_group.db,\n        )\n        self.main_view.update_analysis_plot(\n                    self.preprocessing,\n                    self.signal_process,\n                    [self.sidebar.accordion.channel_selector_input.component.value,\n                    self.sidebar.accordion.channel_selector_output.component.value],\n                    self.sidebar.accordion.toggle_group.stretch,\n                    [self.sidebar.accordion.color_picker_ch1.component.value,\n                    self.sidebar.accordion.color_picker_ch2.component.value,\n                    self.sidebar.accordion.color_picker_result.component.value],\n                    self.sidebar.accordion.method_selector.component.value,\n                    self.sidebar.accordion.window_selector.component.value,\n                    self.sidebar.accordion.overlap_selector.component.value,\n                    self.sidebar.accordion.toggle_group.grid,\n                    self.sidebar.accordion.toggle_x_axis.x_log,\n                    self.sidebar.accordion.toggle_y_axis.y_log,\n                    self.sidebar.accordion.toggle_group.db,\n\n                )\n</code></pre>"},{"location":"frontend_controllers/#fft_analysator.gui.controllers.app_controller.AppController.handle_fileupload_event","title":"handle_fileupload_event","text":"<pre><code>handle_fileupload_event(event)\n</code></pre> <p>Handles the file upload event.</p> <p>This method is called when a file upload event occurs.</p> Source code in <code>src/fft_analysator/gui/controllers/app_controller.py</code> <pre><code>def handle_fileupload_event(self, event):\n    \"\"\"\n    Handles the file upload event.\n\n    This method is called when a file upload event occurs.\n    \"\"\"\n    # Handle the file upload event and update the preprocessing object\n    self.file_paths = self.sidebar.accordion.file_input.file_paths\n\n    if self.file_paths:\n        self.preprocessing = pp.Preprocess(self.file_paths, self.sidebar.accordion.blocksize_selector.component.value)\n        self.signal_process = Signal_Process(channels=[], file_path=self.file_paths,\n                                            block_size=self.sidebar.accordion.blocksize_selector.component.value,\n                                            data_callback=self.preprocessing)\n        # signal_process insert\n        if event.obj == self.sidebar.accordion.file_input.component:\n            self.sidebar.update_file_list()\n            self.sidebar.update_selector(self.preprocessing)\n            self.sidebar.update_channel_selector(self.preprocessing)\n            self.sidebar.update_intslider(self.preprocessing)\n            self.sidebar.update_general_plotting_widgets(self.preprocessing)\n\n    else:\n        self.sidebar.update_file_list()\n        self.sidebar.update_selector()\n        self.sidebar.update_channel_selector()\n        self.sidebar.update_intslider()\n        self.sidebar.update_general_plotting_widgets()\n</code></pre>"},{"location":"frontend_controllers/#fft_analysator.gui.controllers.app_controller.AppController.handle_intslider_event","title":"handle_intslider_event","text":"<pre><code>handle_intslider_event(event)\n</code></pre> <p>Handles the intslider event.</p> <p>This method is called when an intslider event occurs.</p> Source code in <code>src/fft_analysator/gui/controllers/app_controller.py</code> <pre><code>def handle_intslider_event(self, event):\n    \"\"\"\n    Handles the intslider event.\n\n    This method is called when an intslider event occurs.\n    \"\"\"\n    if self.file_paths:\n        if (self.sidebar.accordion.int_slider.component.value &gt; self.preprocessing.current_block_idx):\n            for _ in range(self.sidebar.accordion.int_slider.component.value - self.preprocessing.current_block_idx):\n                self.preprocessing.set_next_data_block()\n\n            self.sidebar.update_color_picker()\n            self.sidebar.update_nav_index()\n            self.main_view.update_signal(\n                self.preprocessing,\n                self.signal_process,\n                [self.sidebar.accordion.channel_selector_input.component.value,\n                self.sidebar.accordion.channel_selector_output.component.value],\n                self.sidebar.accordion.toggle_group.stretch,\n                [self.sidebar.accordion.color_picker_ch1.component.value,\n                self.sidebar.accordion.color_picker_ch2.component.value,\n                self.sidebar.accordion.color_picker_result.component.value],\n                self.sidebar.accordion.window_selector.component.value,\n                self.sidebar.accordion.overlap_selector.component.value,\n                self.sidebar.accordion.toggle_group.grid,\n                self.sidebar.accordion.toggle_x_axis.x_log,\n                self.sidebar.accordion.toggle_y_axis.y_log,\n                self.sidebar.accordion.toggle_group.db,\n            )\n        else:\n            self.preprocessing.set_data_block_to_idx(self.sidebar.accordion.int_slider.component.value)\n            self.sidebar.update_color_picker()\n            self.sidebar.update_nav_index()\n            self.main_view.update_signal(\n                self.preprocessing,\n                self.signal_process,\n                [self.sidebar.accordion.channel_selector_input.component.value,\n                self.sidebar.accordion.channel_selector_output.component.value],\n                self.sidebar.accordion.toggle_group.stretch,\n                [self.sidebar.accordion.color_picker_ch1.component.value,\n                self.sidebar.accordion.color_picker_ch2.component.value,\n                self.sidebar.accordion.color_picker_result.component.value],\n                self.sidebar.accordion.window_selector.component.value,\n                self.sidebar.accordion.overlap_selector.component.value,\n                self.sidebar.accordion.toggle_group.grid,\n                self.sidebar.accordion.toggle_x_axis.x_log,\n                self.sidebar.accordion.toggle_y_axis.y_log,\n                self.sidebar.accordion.toggle_group.db,\n            )\n</code></pre>"},{"location":"frontend_controllers/#fft_analysator.gui.controllers.app_controller.AppController.handle_sidebar_event","title":"handle_sidebar_event","text":"<pre><code>handle_sidebar_event(event)\n</code></pre> <p>Handles the sidebar event.</p> <p>This method is called when a sidebar event occurs.</p> Source code in <code>src/fft_analysator/gui/controllers/app_controller.py</code> <pre><code>def handle_sidebar_event(self, event):\n    \"\"\"\n    Handles the sidebar event.\n\n    This method is called when a sidebar event occurs.\n    \"\"\"\n    # Update the main view when the sidebar event is triggered\n    if ((\n        event.obj == self.sidebar.accordion.color_picker_ch1.component\n        or event.obj == self.sidebar.accordion.color_picker_ch2.component\n        or event.obj == self.sidebar.accordion.color_picker_result.component\n        or event.obj == self.sidebar.accordion.channel_selector_input.component\n        or event.obj == self.sidebar.accordion.channel_selector_output.component\n        or event.obj == self.sidebar.accordion.method_selector.component\n        or event.obj == self.sidebar.accordion.overlap_selector.component\n        or event.obj == self.sidebar.accordion.window_selector.component\n        or event.obj == self.sidebar.accordion.toggle_group.component\n        or event.obj == self.sidebar.accordion.toggle_x_axis.component\n        or event.obj == self.sidebar.accordion.toggle_y_axis.component\n    )\n        and self.file_paths\n        and self.sidebar.accordion.channel_selector_input.component.value is not None\n        and self.sidebar.accordion.channel_selector_output.component.value is not None):\n        # Update the toggle group widgets\n        self.sidebar.update_toggle_group()\n        print(self.sidebar.accordion.toggle_group.component.value)\n        # Update the color picker\n        self.sidebar.update_color_picker()\n        # Update signal\n        self.main_view.update_signal(\n            self.preprocessing,\n            self.signal_process,\n            [self.sidebar.accordion.channel_selector_input.component.value,\n            self.sidebar.accordion.channel_selector_output.component.value],\n            self.sidebar.accordion.toggle_group.stretch,\n            [self.sidebar.accordion.color_picker_ch1.component.value,\n            self.sidebar.accordion.color_picker_ch2.component.value,\n            self.sidebar.accordion.color_picker_result.component.value],\n            self.sidebar.accordion.window_selector.component.value,\n            self.sidebar.accordion.overlap_selector.component.value,\n            self.sidebar.accordion.toggle_group.grid,\n            self.sidebar.accordion.toggle_x_axis.x_log,\n            self.sidebar.accordion.toggle_y_axis.y_log,\n            self.sidebar.accordion.toggle_group.db,\n\n        )\n\n        self.main_view.update_analysis_plot(\n                    self.preprocessing,\n                    self.signal_process,\n                    [self.sidebar.accordion.channel_selector_input.component.value,\n                    self.sidebar.accordion.channel_selector_output.component.value],\n                    self.sidebar.accordion.toggle_group.stretch,\n                    [self.sidebar.accordion.color_picker_ch1.component.value,\n                    self.sidebar.accordion.color_picker_ch2.component.value,\n                    self.sidebar.accordion.color_picker_result.component.value],\n                    self.sidebar.accordion.method_selector.component.value,\n                    self.sidebar.accordion.window_selector.component.value,\n                    self.sidebar.accordion.overlap_selector.component.value,\n                    self.sidebar.accordion.toggle_group.grid,\n                    self.sidebar.accordion.toggle_x_axis.x_log,\n                    self.sidebar.accordion.toggle_y_axis.y_log,\n                    self.sidebar.accordion.toggle_group.db,\n                )\n    else:\n        self.sidebar.update_color_picker()\n        self.main_view.update_signal(\n            self.preprocessing,\n            self.signal_process,\n            [],\n            self.sidebar.accordion.toggle_group.stretch,\n            [self.sidebar.accordion.color_picker_ch1.component.value,\n            self.sidebar.accordion.color_picker_ch2.component.value,\n            self.sidebar.accordion.color_picker_result.component.value],\n            self.sidebar.accordion.window_selector.component.value,\n            self.sidebar.accordion.overlap_selector.component.value,\n            self.sidebar.accordion.toggle_group.grid,\n            self.sidebar.accordion.toggle_x_axis.x_log,\n            self.sidebar.accordion.toggle_y_axis.y_log,\n            self.sidebar.accordion.toggle_group.db,\n        )\n\n        self.main_view.update_analysis_plot(\n                    self.preprocessing,\n                    self.signal_process,\n                    [],\n                    self.sidebar.accordion.toggle_group.stretch,\n                    [self.sidebar.accordion.color_picker_ch1.component.value,\n                    self.sidebar.accordion.color_picker_ch2.component.value,\n                    self.sidebar.accordion.color_picker_result.component.value],\n                    self.sidebar.accordion.method_selector.component.value,\n                    self.sidebar.accordion.window_selector.component.value,\n                    self.sidebar.accordion.overlap_selector.component.value,\n                    self.sidebar.accordion.toggle_group.grid,\n                    self.sidebar.accordion.toggle_x_axis.x_log,\n                    self.sidebar.accordion.toggle_y_axis.y_log,\n                    self.sidebar.accordion.toggle_group.db,\n                )\n</code></pre>"},{"location":"frontend_controllers/#fft_analysator.gui.controllers.app_controller.AppController.handle_table_choose_event","title":"handle_table_choose_event","text":"<pre><code>handle_table_choose_event(event)\n</code></pre> <p>Handles the table choose event.</p> <p>This method is called when a table choose event occurs.</p> Source code in <code>src/fft_analysator/gui/controllers/app_controller.py</code> <pre><code>def handle_table_choose_event(self, event):\n    \"\"\"\n    Handles the table choose event.\n\n    This method is called when a table choose event occurs.\n    \"\"\"\n    # Update the main view when the table chooser event is triggered\n    # Note, we could also split this into multiple functions\n    if event.obj == self.sidebar.accordion.selector.component:\n        if self.sidebar.accordion.selector.component.value:\n            self.preprocessing.table_key = self.sidebar.accordion.selector.component.value\n            self.sidebar.update_channel_selector(self.preprocessing)\n</code></pre>"},{"location":"frontend_controllers/#fft_analysator.gui.controllers.app_controller.AppController.handle_update_analysis_event","title":"handle_update_analysis_event","text":"<pre><code>handle_update_analysis_event(event)\n</code></pre> <p>Handles the update analysis event.</p> <p>This method is called when an update analysis event occurs.</p> Source code in <code>src/fft_analysator/gui/controllers/app_controller.py</code> <pre><code>def handle_update_analysis_event(self, event):\n    \"\"\"\n    Handles the update analysis event.\n\n    This method is called when an update analysis event occurs.\n    \"\"\"\n    if (self.file_paths\n        and self.sidebar.accordion.channel_selector_input.component.value is not None\n        and self.sidebar.accordion.channel_selector_output.component.value is not None):\n\n        self.main_view.update_signal(\n            self.preprocessing,\n            self.signal_process,\n            [self.sidebar.accordion.channel_selector_input.component.value,\n            self.sidebar.accordion.channel_selector_output.component.value],\n            self.sidebar.accordion.toggle_group.stretch,\n            [self.sidebar.accordion.color_picker_ch1.component.value,\n            self.sidebar.accordion.color_picker_ch2.component.value,\n            self.sidebar.accordion.color_picker_result.component.value],\n            self.sidebar.accordion.window_selector.component.value,\n            self.sidebar.accordion.overlap_selector.component.value,\n            self.sidebar.accordion.toggle_group.grid,\n            self.sidebar.accordion.toggle_x_axis.x_log,\n            self.sidebar.accordion.toggle_y_axis.y_log,\n            self.sidebar.accordion.toggle_group.db,\n        )\n\n        self.main_view.update_analysis_plot(\n                    self.preprocessing,\n                    self.signal_process,\n                    [self.sidebar.accordion.channel_selector_input.component.value,\n                    self.sidebar.accordion.channel_selector_output.component.value],\n                    self.sidebar.accordion.toggle_group.stretch,\n                    [self.sidebar.accordion.color_picker_ch1.component.value,\n                    self.sidebar.accordion.color_picker_ch2.component.value,\n                    self.sidebar.accordion.color_picker_result.component.value],\n                    self.sidebar.accordion.method_selector.component.value,\n                    self.sidebar.accordion.window_selector.component.value,\n                    self.sidebar.accordion.overlap_selector.component.value,\n                    self.sidebar.accordion.toggle_group.grid,\n                    self.sidebar.accordion.toggle_x_axis.x_log,\n                    self.sidebar.accordion.toggle_y_axis.y_log,\n                    self.sidebar.accordion.toggle_group.db,\n                )\n    else:\n        self.main_view.update_signal(\n            self.preprocessing,\n            self.signal_process,\n            [self.sidebar.accordion.channel_selector_input.component.value,\n            self.sidebar.accordion.channel_selector_output.component.value],\n            self.sidebar.accordion.toggle_group.stretch,\n            [self.sidebar.accordion.color_picker_ch1.component.value,\n            self.sidebar.accordion.color_picker_ch2.component.value,\n            self.sidebar.accordion.color_picker_result.component.value],\n            self.sidebar.accordion.window_selector.component.value,\n            self.sidebar.accordion.overlap_selector.component.value,\n            self.sidebar.accordion.toggle_group.grid,\n            self.sidebar.accordion.toggle_x_axis.x_log,\n            self.sidebar.accordion.toggle_y_axis.y_log,\n            self.sidebar.accordion.toggle_group.db,\n        )\n\n        self.main_view.update_analysis_plot(\n            self.preprocessing,\n            self.signal_process,\n            [],\n            self.sidebar.accordion.toggle_group.stretch,\n            [self.sidebar.accordion.color_picker_ch1.component.value,\n            self.sidebar.accordion.color_picker_ch2.component.value,\n            self.sidebar.accordion.color_picker_result.component.value],\n            self.sidebar.accordion.method_selector.component.value,\n            self.sidebar.accordion.window_selector.component.value,\n            self.sidebar.accordion.overlap_selector.component.value,\n            self.sidebar.accordion.toggle_group.grid,\n            self.sidebar.accordion.toggle_x_axis.x_log,\n            self.sidebar.accordion.toggle_y_axis.y_log,\n            self.sidebar.accordion.toggle_group.db,\n        )\n</code></pre>"},{"location":"frontend_controllers/#fft_analysator.gui.controllers.app_controller.AppController.servable","title":"servable","text":"<pre><code>servable()\n</code></pre> <p>Makes the application servable.</p> Source code in <code>src/fft_analysator/gui/controllers/app_controller.py</code> <pre><code>def servable(self):\n    \"\"\"\n    Makes the application servable.\n    \"\"\"\n    # Serve app layout\n    self.template_layout.servable()\n</code></pre>"},{"location":"frontend_views/","title":"Views","text":""},{"location":"frontend_views/#views","title":"Views","text":""},{"location":"frontend_views/#sidebar","title":"Sidebar","text":""},{"location":"frontend_views/#fft_analysator.gui.views.sidebar","title":"sidebar","text":""},{"location":"frontend_views/#fft_analysator.gui.views.sidebar.Sidebar","title":"Sidebar","text":"<pre><code>Sidebar(callback_fileupload=None, callback=None, callback_table_chooser=None, callback_intslider=None, callback_block_selector=None, callback_analysis_event=None, callback_exporter_event=None, callback_method_event=None)\n</code></pre> <p>A class used to represent the sidebar of the application.</p> <p>This class is responsible for handling user interactions with the sidebar and updating the sidebar's state accordingly.</p>"},{"location":"frontend_views/#fft_analysator.gui.views.sidebar.Sidebar--attributes","title":"Attributes","text":"<p>accordion : object     An instance of the Accordion class. layout : object     A panel Column layout containing the accordion component. ch : list     A list of selected channels. amount_ch : int     The number of selected channels.</p>"},{"location":"frontend_views/#fft_analysator.gui.views.sidebar.Sidebar--methods","title":"Methods","text":"<p>update_channel_selector(data_callback)     Updates the channel selector based on the provided data. update_color_picker()     Updates the color picker based on the selected channels.</p> <p>The accordion attribute is initialized as an Accordion instance. The layout attribute is initialized as a panel Column layout containing the accordion component. The ch attribute is initialized as an empty list. The amount_ch attribute is initialized as 0.</p> Source code in <code>src/fft_analysator/gui/views/sidebar.py</code> <pre><code>def __init__(self, callback_fileupload=None, callback=None, callback_table_chooser=None, callback_intslider=None,\n             callback_block_selector=None, callback_analysis_event=None, callback_exporter_event=None,\n             callback_method_event=None):\n    \"\"\"\n            Constructs all the necessary attributes for the Sidebar object.\n\n            The accordion attribute is initialized as an Accordion instance.\n            The layout attribute is initialized as a panel Column layout containing the accordion component.\n            The ch attribute is initialized as an empty list.\n            The amount_ch attribute is initialized as 0.\n            \"\"\"\n\n    self.accordion = Accordion()\n    self.layout = self.accordion.component\n\n    if (callback or callback_fileupload or callback_table_chooser or callback_analysis_event or\n        callback_exporter_event or callback_method_event):\n        self.accordion.file_input.component.param.watch(callback_fileupload, \"value\")\n        self.accordion.channel_selector_input.component.param.watch(callback, \"value\")\n        self.accordion.channel_selector_output.component.param.watch(callback, \"value\")\n        self.accordion.color_picker_ch1.component.param.watch(callback, \"value\")\n        self.accordion.color_picker_ch2.component.param.watch(callback, \"value\")\n        self.accordion.color_picker_result.component.param.watch(callback, \"value\")\n        self.accordion.selector.component.param.watch(callback_table_chooser, \"value\")\n        self.accordion.int_slider.component.param.watch(callback_intslider, \"value\")\n        self.accordion.blocksize_selector.component.param.watch(callback_block_selector, \"value\")\n        self.accordion.method_selector.component.param.watch(callback_analysis_event, \"value\")\n        self.accordion.overlap_selector.component.param.watch(callback_analysis_event, \"value\")\n        self.accordion.window_selector.component.param.watch(callback_analysis_event, \"value\")\n        self.accordion.file_exporter.component.param.watch(callback_exporter_event, \"value\")\n        self.accordion.method_selector.component.param.watch(callback_method_event, \"value\")\n        self.accordion.toggle_group.component.param.watch(callback, \"value\")\n        self.accordion.toggle_x_axis.component.param.watch(callback, \"value\")\n        self.accordion.toggle_y_axis.component.param.watch(callback, \"value\")\n</code></pre>"},{"location":"frontend_views/#fft_analysator.gui.views.sidebar.Sidebar.servable","title":"servable","text":"<pre><code>servable()\n</code></pre> <p>Makes the sidebar servable.</p> Source code in <code>src/fft_analysator/gui/views/sidebar.py</code> <pre><code>def servable(self):\n    \"\"\"\n    Makes the sidebar servable.\n    \"\"\"\n    return self.layout.servable(target=\"sidebar\")\n</code></pre>"},{"location":"frontend_views/#fft_analysator.gui.views.sidebar.Sidebar.update_channel_selector","title":"update_channel_selector","text":"<pre><code>update_channel_selector(data_callback=None)\n</code></pre> <p>Updates the channel selector based on the provided data.</p>"},{"location":"frontend_views/#fft_analysator.gui.views.sidebar.Sidebar.update_channel_selector--parameters","title":"Parameters","text":"<p>data_callback : function     A callback function to retrieve the data.</p> Source code in <code>src/fft_analysator/gui/views/sidebar.py</code> <pre><code>def update_channel_selector(self, data_callback=None):\n    \"\"\"\n    Updates the channel selector based on the provided data.\n\n    Parameters\n    ----------\n    data_callback : function\n        A callback function to retrieve the data.\n    \"\"\"\n    if data_callback:\n        self.accordion.channel_selector_output.component.disabled = False\n        self.accordion.channel_selector_input.component.disabled = False\n        self.accordion.channel_selector_output.component.name = \"Output channel:\"\n        self.accordion.channel_selector_input.component.name = \"Input channel:\"\n        self.accordion.channel_selector_input.component.options = (list(range(data_callback.get_channel_count())))\n        self.accordion.channel_selector_output.component.options = (list(range(data_callback.get_channel_count())))\n    else:\n        self.accordion.channel_selector_output.component.name = \"No data chosen!\"\n        self.accordion.channel_selector_input.component.name = \"No data chosen!\"\n        self.accordion.channel_selector_input.component.options = []\n        self.accordion.channel_selector_output.component.options = []\n        self.accordion.channel_selector_output.component.disabled = True\n        self.accordion.channel_selector_input.component.disabled = True\n</code></pre>"},{"location":"frontend_views/#fft_analysator.gui.views.sidebar.Sidebar.update_color_picker","title":"update_color_picker","text":"<pre><code>update_color_picker()\n</code></pre> <p>Updates the color picker based on the selected channels.</p> Source code in <code>src/fft_analysator/gui/views/sidebar.py</code> <pre><code>def update_color_picker(self):\n    \"\"\"\n    Updates the color picker based on the selected channels.\n    \"\"\"\n    # The selector always has a value, so we can check if the options are set\n    if (self.accordion.channel_selector_input.component.value is not None\n        and self.accordion.channel_selector_output.component.value is not None):\n\n        self.ch = list(dict.fromkeys([self.accordion.channel_selector_input.component.value,\n                                      self.accordion.channel_selector_output.component.value]))\n        self.amount_ch = len(self.ch)\n\n        if self.amount_ch == 1:\n            self.accordion.color_picker_ch1.component.visible = True\n            self.accordion.color_picker_ch2.component.visible = False\n            self.accordion.color_picker_ch1.component.name = f'CH: {self.ch[0]}'\n            self.accordion.color_picker_ch2.component.name = ''\n            self.amount_ch = 0\n        elif self.amount_ch == 2:\n            self.accordion.color_picker_ch1.component.visible = True\n            self.accordion.color_picker_ch2.component.visible = True\n            self.accordion.color_picker_result.component.visible = True\n            self.accordion.color_picker_ch1.component.name = f'CH: {self.ch[0]}'\n            self.accordion.color_picker_ch2.component.name = f'CH: {self.ch[1]}'\n            self.accordion.color_picker_result.component.name = f'Result'\n            self.amount_ch = 0\n\n    else:\n        self.accordion.color_picker_ch1.component.visible = False\n        self.accordion.color_picker_ch2.component.visible = False\n        self.accordion.color_picker_result.component.visible = False\n        self.accordion.color_picker_ch1.component.name = ''\n        self.accordion.color_picker_ch2.component.name = ''\n        self.accordion.color_picker_result.component.name = ''\n        self.amount_ch = 0\n</code></pre>"},{"location":"frontend_views/#fft_analysator.gui.views.sidebar.Sidebar.update_file_list","title":"update_file_list","text":"<pre><code>update_file_list()\n</code></pre> <p>Updates the file list based on the file paths in the file input component.</p> Source code in <code>src/fft_analysator/gui/views/sidebar.py</code> <pre><code>def update_file_list(self):\n    \"\"\"\n    Updates the file list based on the file paths in the file input component.\n    \"\"\"\n    if self.accordion.file_input.file_paths:\n        self.accordion.data_selector.component.options = [path.basename(self.accordion.file_input.file_paths)]\n\n    else:\n        self.accordion.data_selector.component.options = []\n</code></pre>"},{"location":"frontend_views/#fft_analysator.gui.views.sidebar.Sidebar.update_general_plotting_widgets","title":"update_general_plotting_widgets","text":"<pre><code>update_general_plotting_widgets(data_callback=None)\n</code></pre> <p>Updates the general plotting widgets based on the provided data.</p>"},{"location":"frontend_views/#fft_analysator.gui.views.sidebar.Sidebar.update_general_plotting_widgets--parameters","title":"Parameters","text":"<p>data_callback : function, optional     A callback function to retrieve the data. If not provided, the widgets are disabled.</p> Source code in <code>src/fft_analysator/gui/views/sidebar.py</code> <pre><code>def update_general_plotting_widgets(self, data_callback=None):\n    \"\"\"\n    Updates the general plotting widgets based on the provided data.\n\n    Parameters\n    ----------\n    data_callback : function, optional\n        A callback function to retrieve the data. If not provided, the widgets are disabled.\n    \"\"\"\n    if data_callback:\n        self.accordion.toggle_group.component.disabled = False\n        self.accordion.toggle_x_axis.component.disabled = False\n        self.accordion.toggle_y_axis.component.disabled = False\n        self.accordion.window_selector.component.disabled = False\n        self.accordion.overlap_selector.component.disabled = False\n        self.accordion.method_selector.component.disabled = False\n    else:\n        self.accordion.toggle_group.component.disabled = True\n        self.accordion.toggle_x_axis.component.disabled = True\n        self.accordion.toggle_y_axis.component.disabled = True\n        self.accordion.window_selector.component.disabled = True\n        self.accordion.overlap_selector.component.disabled = True\n        self.accordion.method_selector.component.disabled = True\n</code></pre>"},{"location":"frontend_views/#fft_analysator.gui.views.sidebar.Sidebar.update_intslider","title":"update_intslider","text":"<pre><code>update_intslider(data_callback=None)\n</code></pre> <p>Updates the integer slider and the navigation buttons based on the provided data.</p>"},{"location":"frontend_views/#fft_analysator.gui.views.sidebar.Sidebar.update_intslider--parameters","title":"Parameters","text":"<p>data_callback : function, optional     A callback function to retrieve the data. If not provided, the integer slider and the navigation buttons are disabled.</p> Source code in <code>src/fft_analysator/gui/views/sidebar.py</code> <pre><code>def update_intslider(self, data_callback=None):\n    \"\"\"\n    Updates the integer slider and the navigation buttons based on the provided data.\n\n    Parameters\n    ----------\n    data_callback : function, optional\n        A callback function to retrieve the data. If not provided, the integer slider and the navigation buttons are disabled.\n    \"\"\"\n    if self.accordion.file_input.file_paths and data_callback:\n        self.accordion.int_slider.component.disabled = False\n        self.accordion.int_slider.component.value = 0\n        self.accordion.int_slider.component.start = 0\n        self.accordion.int_slider.component.end = math.ceil(\n            (data_callback.source.numsamples) / data_callback.block_size) - 1\n\n        # update the navigation buttons as well since they are coupled with the int_slider\n        self.accordion.gen_nav.index_box.disabled = False\n        self.accordion.gen_nav.index_box.start = self.accordion.int_slider.component.start\n        self.accordion.gen_nav.index_box.end = self.accordion.int_slider.component.end\n        self.accordion.gen_nav.index_box.name = f'{self.accordion.int_slider.component.value}/{self.accordion.gen_nav.index_box.start}-{self.accordion.gen_nav.index_box.end}'\n        self.accordion.gen_nav.button_back.disabled = False\n        self.accordion.gen_nav.button_forward.disabled = False\n        self.accordion.gen_nav.goto_button.disabled = False\n        self.accordion.gen_nav.reset_button.disabled = False\n\n    else:\n        self.accordion.int_slider.component.disabled = True\n        self.accordion.int_slider.component.value = 0\n\n        # update the navigation buttons as well since they are coupled with the int_slider\n        self.accordion.gen_nav.index_box.value = 0\n        self.accordion.gen_nav.index_box.name = \"Index:\"\n        self.accordion.gen_nav.index_box.disabled = True\n        self.accordion.gen_nav.button_back.disabled = True\n        self.accordion.gen_nav.button_forward.disabled = True\n        self.accordion.gen_nav.goto_button.disabled = True\n        self.accordion.gen_nav.reset_button.disabled = True\n</code></pre>"},{"location":"frontend_views/#fft_analysator.gui.views.sidebar.Sidebar.update_nav_index","title":"update_nav_index","text":"<pre><code>update_nav_index()\n</code></pre> <p>Updates the navigation index based on the provided index.</p>"},{"location":"frontend_views/#fft_analysator.gui.views.sidebar.Sidebar.update_nav_index--parameters","title":"Parameters","text":"<p>index : int     The index to update the navigation index to.</p> Source code in <code>src/fft_analysator/gui/views/sidebar.py</code> <pre><code>def update_nav_index(self):\n    \"\"\"\n    Updates the navigation index based on the provided index.\n\n    Parameters\n    ----------\n    index : int\n        The index to update the navigation index to.\n    \"\"\"\n    self.accordion.gen_nav.index_box.name = f'{self.accordion.int_slider.component.value}/{self.accordion.gen_nav.index_box.start}-{self.accordion.gen_nav.index_box.end}'\n</code></pre>"},{"location":"frontend_views/#fft_analysator.gui.views.sidebar.Sidebar.update_selector","title":"update_selector","text":"<pre><code>update_selector(data_callback=None)\n</code></pre> <p>Updates the selector based on the provided data.</p>"},{"location":"frontend_views/#fft_analysator.gui.views.sidebar.Sidebar.update_selector--parameters","title":"Parameters","text":"<p>data_callback : function, optional     A callback function to retrieve the data. If not provided, the selector is cleared.</p> Source code in <code>src/fft_analysator/gui/views/sidebar.py</code> <pre><code>def update_selector(self, data_callback=None):\n    \"\"\"\n    Updates the selector based on the provided data.\n\n    Parameters\n    ----------\n    data_callback : function, optional\n        A callback function to retrieve the data. If not provided, the selector is cleared.\n    \"\"\"\n    if data_callback:\n        self.accordion.selector.component.options = data_callback.get_table_names()\n        self.accordion.selector.component.value = data_callback.get_table_names()[0]\n        if (len(data_callback.get_table_names()) + 2) &gt; 3:\n            self.accordion.selector.component.size = len(data_callback.get_table_names()) + 2\n\n    else:\n        self.accordion.selector.component.options = []\n        self.accordion.selector.component.value = \"\"\n\n    return True\n</code></pre>"},{"location":"frontend_views/#main-view","title":"Main View","text":""},{"location":"frontend_views/#fft_analysator.gui.views.main_view","title":"main_view","text":""},{"location":"frontend_views/#fft_analysator.gui.views.main_view.MainView","title":"MainView","text":"<pre><code>MainView()\n</code></pre> <p>A class used to represent the main view of the application.</p> <p>This class is responsible for updating the signal and analysis plots based on the provided data.</p>"},{"location":"frontend_views/#fft_analysator.gui.views.main_view.MainView--attributes","title":"Attributes","text":"<p>tabs : object     An instance of the Tabs class. layout : object     A panel Column layout containing the tabs component.</p>"},{"location":"frontend_views/#fft_analysator.gui.views.main_view.MainView--methods","title":"Methods","text":"<p>update_signal(data_callback, channels, stretch_value, color_picker_value, window, overlap)     Updates the signal plots based on the provided data. update_analysis_plot(data_callback, channels, stretch_value, color_picker_value, analysis_callback, window, overlap)     Updates the analysis plots based on the provided data.</p> <p>The tabs attribute is initialized as a Tabs instance. The layout attribute is initialized as a panel Column layout containing the tabs component.</p> Source code in <code>src/fft_analysator/gui/views/main_view.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Constructs all the necessary attributes for the MainView object.\n\n    The tabs attribute is initialized as a Tabs instance.\n    The layout attribute is initialized as a panel Column layout containing the tabs component.\n    \"\"\"\n    self.tabs = Tabs()\n    self.layout = pn.Column(self.tabs.component, sizing_mode='stretch_width')\n</code></pre>"},{"location":"frontend_views/#fft_analysator.gui.views.main_view.MainView.servable","title":"servable","text":"<pre><code>servable()\n</code></pre> <p>Makes the main view servable.</p> Source code in <code>src/fft_analysator/gui/views/main_view.py</code> <pre><code>def servable(self):\n    \"\"\"\n    Makes the main view servable.\n    \"\"\"\n    self.layout.servable(target=\"main\")\n</code></pre>"},{"location":"frontend_views/#fft_analysator.gui.views.main_view.MainView.update_analysis_plot","title":"update_analysis_plot","text":"<pre><code>update_analysis_plot(data_callback, signal_process_callback, channels, stretch_value, color_picker_value, analysis_callback, window, overlap, show_grid, x_log, y_log, db)\n</code></pre> <p>Updates the analysis plots based on the provided data.</p>"},{"location":"frontend_views/#fft_analysator.gui.views.main_view.MainView.update_analysis_plot--parameters","title":"Parameters","text":"<p>data_callback : function     A callback function to retrieve the data. channels : list     A list of channels to plot. stretch_value : int     The stretch value for the plot. color_picker_value : str     The selected color for the plot. analysis_callback : function     A callback function to perform the analysis. window : str     The selected window function. overlap : int     The overlap value for the plot.</p> Source code in <code>src/fft_analysator/gui/views/main_view.py</code> <pre><code>def update_analysis_plot(self, data_callback, signal_process_callback, channels, stretch_value, color_picker_value, analysis_callback,\n                         window, overlap, show_grid,x_log,y_log, db):\n    \"\"\"\n    Updates the analysis plots based on the provided data.\n\n    Parameters\n    ----------\n    data_callback : function\n        A callback function to retrieve the data.\n    channels : list\n        A list of channels to plot.\n    stretch_value : int\n        The stretch value for the plot.\n    color_picker_value : str\n        The selected color for the plot.\n    analysis_callback : function\n        A callback function to perform the analysis.\n    window : str\n        The selected window function.\n    overlap : int\n        The overlap value for the plot.\n    \"\"\"\n    if channels:\n        signal_process_callback.set_parameters(channels, window, overlap)\n\n        plot = Plotter(signal_process_callback, channels, self.tabs, data_callback, window, overlap,\n                        color_picker_value, stretch_value, show_grid,x_log,y_log, db)\n\n        # plot analysis function\n        if analysis_callback == \"Auto Spectral Density - Input\":\n            # generate Auto Spectral Density plot\n            plot.create_auto_and_cross_power_spectrum_plot(type='xx')\n\n        elif analysis_callback == \"Auto Spectral Density - Output\":\n            # generate Auto Spectral Density plot\n            plot.create_auto_and_cross_power_spectrum_plot(type='yy')\n\n        elif analysis_callback == \"Cross Spectral Density\":\n            # generate Cross Spectral Density plot\n            plot.create_auto_and_cross_power_spectrum_plot(type='xy')\n\n        elif analysis_callback == \"Auto Correlation - Input\":\n            # generate Auto Correlation - Input plot\n            plot.create_correlation_plot(type='xx')\n\n        elif analysis_callback == \"Auto Correlation - Output\":\n            # generate Auto Correlation - Output plot\n            plot.create_correlation_plot(type='yy')\n\n        elif analysis_callback == \"Cross Correlation\":\n            # generate Cross Spectral Density plot\n            plot.create_correlation_plot(type='xy')\n\n        elif analysis_callback == \"Coherence\":\n            # generate coherence plot\n            plot.create_coherence_plot()\n\n        elif analysis_callback == \"No Analysis Function\":\n            self.tabs.component[3] = (self.tabs.str_analysis_function_tab, \"No Analysis Function is choosen\")\n\n        elif analysis_callback == \"Impulse Response\" or analysis_callback == \"Amplitude Response\" or analysis_callback == \"Phase Response\":\n\n            self.tabs.component[3] = (self.tabs.str_analysis_function_tab, \"No Analysis Function for this Tab is choosen\")\n\n    else:\n        self.tabs.component[3] = (self.tabs.str_analysis_function_tab, 'No data chosen!')\n</code></pre>"},{"location":"frontend_views/#fft_analysator.gui.views.main_view.MainView.update_signal","title":"update_signal","text":"<pre><code>update_signal(data_callback, signal_process_callback, channels, stretch_value, color_picker_value, window, overlap, show_grid, x_log, y_log, db)\n</code></pre> <p>Updates the signal plots based on the provided data.</p>"},{"location":"frontend_views/#fft_analysator.gui.views.main_view.MainView.update_signal--parameters","title":"Parameters","text":"<p>data_callback : function     A callback function to retrieve the data. channels : list     A list of channels to plot. stretch_value : int     The stretch value for the plot. color_picker_value : str     The selected color for the plot. window : str     The selected window function. overlap : int     The overlap value for the plot.</p> Source code in <code>src/fft_analysator/gui/views/main_view.py</code> <pre><code>def update_signal(self, data_callback, signal_process_callback, channels, stretch_value, color_picker_value, window, overlap, show_grid,x_log,y_log, db):\n    \"\"\"\n    Updates the signal plots based on the provided data.\n\n    Parameters\n    ----------\n    data_callback : function\n        A callback function to retrieve the data.\n    channels : list\n        A list of channels to plot.\n    stretch_value : int\n        The stretch value for the plot.\n    color_picker_value : str\n        The selected color for the plot.\n    window : str\n        The selected window function.\n    overlap : int\n        The overlap value for the plot.\n    \"\"\"\n    if channels:\n        signal_process_callback.set_parameters(channels, window, overlap)\n\n        print(show_grid)\n        plot = Plotter(signal_process_callback, channels, self.tabs, data_callback, window, overlap,\n                        color_picker_value, stretch_value, show_grid,x_log,y_log, db)\n\n        # generate time plot\n        plot.create_time_plot()\n\n        # generate frequency response plot\n        plot.create_frequency_response_plot()\n\n        # generate frequency response plot\n        plot.create_impulse_response_plot()\n    else:\n        self.tabs.component[0] = (self.tabs.str_signal_tab, 'No data chosen!')\n        self.tabs.component[1] = (self.tabs.str_frequency_response_tab, 'No data chosen!')\n        self.tabs.component[2] = (self.tabs.str_impulse_response_tab, 'No data chosen!')\n</code></pre>"},{"location":"installation/","title":"Installation","text":"<p>There are two different ways to install the FFT-Analyzer:</p> <ol> <li>Download the source code, install the packages from the <code>requirement.txt</code> by navigating to the root directory and using the command <code>pip install -r requirements.txt</code>, afterwards to start the app use <code>panel serve src\\fft_analysator\\app.py --autoreload</code> and navigate to the url given to you inside of the console in the browser of your choice.</li> <li>Alternatively, you can download the source code and install the package by navigating to the root and using the command <code>pip install .</code> or <code>pip install setup.py</code>. Afterwards you can start the app by importing it by doing: <pre><code>from fft_analysator.app import App\n\nApp().serve_app()\n</code></pre> If you only want to use the API and are not interested in using the GUI, you can refer to the API documentation and should preferably choose option 2.</li> </ol>"},{"location":"user_guide_analysis_functions/","title":"Analysis functions","text":"<p>Correlation Function: The correlation function is used to investigate temporal relationships within a signal or between two signals. The autocorrelation function considers the investigation with one signal and is defined by:</p> \\[ \\psi_{xx}(\\tau) = \\lim_{T \\to \\infty} \\frac{1}{T} \\int_0^T x(t)x(t+\\tau)dt. \\] <p>The function is symmetric (\\(\\psi_{xx}(\\tau) = \\psi_{xx}(-\\tau)\\)) due to the commutativity of the factors of the product in the integrand. For two different signals \\(x\\) and \\(y\\), the cross-correlation function can be calculated:</p> \\[ \\psi_{xy}(\\tau) = \\lim_{T \\to \\infty} \\frac{1}{T} \\int_0^T x(t)y(t+\\tau)dt. \\] <p>The function does not have symmetry (\\(\\psi_{xy}(\\tau) = \\psi_{yx}(-\\tau)\\)).</p> <p>Power Spectral Density: The power spectral density (or simply, power spectrum) for a signal indicates the distribution of the power of the signal across different frequencies and can be derived from the autocorrelation function:</p> \\[ S_{xx}(f) = \\int_{-\\infty}^{+\\infty} \\psi(\\tau)e^{-j2\\pi f\\tau}d\\tau. \\] <p>The relationship between the correlation function and the power spectrum is thus given by Fourier transformation:</p> \\[ \\psi_{xx}(\\tau) = \\int_{-\\infty}^{+\\infty} S_{xx}(f)e^{j2\\pi f\\tau}df. \\] <p>Due to the properties of the Fourier transformation, the power spectrum is also symmetric \\(S_{xx}(-f) = S_{xx}(f)\\). As with the autocorrelation function, only the one-sided spectrum is considered for physical relevance:</p> \\[ G_{xx}(f) = 2S_{xx}(f), \\quad f \\geq 0. \\] <p>For two signals, the cross-power spectrum can be calculated:</p> \\[ \\underline{S}_{xy}(f) = \\int_{-\\infty}^{+\\infty} \\psi_{xy}(\\tau)e^{-j2\\pi f\\tau}d\\tau. \\] <p>The cross-power spectrum has the following properties:</p> \\[ \\underline{S}_{xy}(-f) = \\underline{S}_{xy}^*(f) \\quad \\text{and} \\quad \\underline{S}_{xy}(f) = \\underline{S}_{yx}^*(f). \\] <p>Here too, it makes sense to restrict the spectrum to positive frequencies, and one obtains for the one-sided spectrum \\(\\underline{G}_{xy} = 2\\underline{S}_{xy}(f)\\), \\(f \\geq 0\\).</p> <p>For practical applications, power spectra are calculated efficiently using Fourier transformation, exploiting the relationship between correlation functions and power spectra to compute the correlation functions. For a discrete time signal \\(x_i(t)\\), the Fourier transformation over an observation period \\(0 \\leq t \\leq T\\) is defined by:</p> \\[ \\underline{X}_i(f,T) = \\int_0^T x_i(t)e^{-j2\\pi ft}dt. \\] <p>With the magnitude square of the Fourier transform, the distribution of signal power over the frequencies \\(f\\) for \\(x_i(t)\\) can be indicated by:</p> \\[ S_{xx}(f,T,i) = \\frac{1}{T} | \\underline{X}_i(f,T)|^2 = \\frac{1}{T} \\underline{X}_i(f,T)\\underline{X}_i^*(f,T). \\] <p>By taking the expected value for all discrete values \\(i\\), the auto or cross-power spectrum can then be determined:</p> \\[ G_{xx}(f) = 2 \\cdot \\lim_{T \\to \\infty} E(\\underline{X}_i(f,T)\\underline{X}_i^*(f,T)), \\] \\[ \\underline{G}_{xy}(f) = 2 \\cdot \\lim_{T \\to \\infty} E(\\underline{X}_i(f,T)\\underline{Y}_i^*(f,T)). \\] <p>Coherence: Coherence is a statistical measure for the linear relationship between two signals, can take values between \\(0 \\leq \\gamma_{xy}^2 \\leq 1\\) and is calculated as follows:</p> \\[ \\gamma_{xy}^2(f) = \\frac{| \\underline{G_{xy}}(f)^2|}{G_{xx}(g)G_{yy}(f)}. \\] <p>Frequency Response: The frequency response shows how a system processes signals of different frequencies. To account for the possibility of noise in the output or input signal, there are various approaches to provide a suitable estimate of the frequency response without systematic errors. A possible estimate based on the given power spectra is:</p> \\[ \\underline{H}_1(f) = \\frac{\\underline{G}_{xy}(f)}{G_{xx}(f)}. \\] <p>Impulse Response: Frequency response and impulse response are linked via the Fourier transform. Thus, the impulse response, which describes the reaction of a physical system to a Dirac pulse, can be obtained from the inverse Fourier transformation of the frequency response.</p>"}]}