{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":"<p>Das ist die Dokumentation f\u00fcr den FFT-Analysator.</p>"},{"location":"dev_backend_documentation/","title":"Backend Documentation","text":""},{"location":"dev_backend_documentation/#preprocessing","title":"Preprocessing","text":""},{"location":"dev_backend_documentation/#fft_analysator.analysis.preprocessing","title":"preprocessing","text":""},{"location":"dev_backend_documentation/#fft_analysator.analysis.preprocessing.Preprocess","title":"Preprocess","text":"<pre><code>Preprocess(file_paths=None, block_size=1024)\n</code></pre> <p>The Preprocess class handles everything after importing the user file. It is an interface between Acoular and our internal Signalprocessing class. It contains information about the block size, data, channel count and size and sample frequency. It is able to return the complete data as a Numpy array or iterate over the defined block size.</p> <p>Parameters:</p> Name Type Description Default <code>file_paths</code> <code>object</code> <p>Get the callback to the data object</p> <code>None</code> <code>block_size</code> <code>int</code> <p>Length of data block.</p> <code>1024</code> Source code in <code>src/fft_analysator/analysis/preprocessing.py</code> <pre><code>def __init__(self, file_paths=None, block_size=1024):\n\n    self.file_paths = file_paths\n    self.block_size = block_size\n\n    if file_paths:\n        self.table_key = self.get_table_names()[0]\n        self.converted_file = self.convert_data()\n        self.source = ac.TimeSamples(name=self.file_paths)\n        self.source_result = self.source.result(num=self.block_size)\n        self.selected_data_block = next(self.source_result)\n\n    self.current_block_idx = 0\n\n    # brauchen wir das wirklich alles? wir sollten wirklich schauen, was wir als Attribut speichern\n    # oft lohnt sich returnen und in der plot function weiterverarbeiten mehr\n    self.data = None\n    self.channel_count = None\n    self.channel_size = None\n    self.selected_channel_data = np.array([])\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.preprocessing.Preprocess.convert_data","title":"convert_data","text":"<pre><code>convert_data()\n</code></pre> <p>Convert_data reads the .h5 file and reads the data. Not used for Signalprocessing.</p> Source code in <code>src/fft_analysator/analysis/preprocessing.py</code> <pre><code>def convert_data(self):\n    \"\"\"\n    Convert_data reads the .h5 file and reads the data. Not used for Signalprocessing.\n    \"\"\"\n    with h5py.File(self.file_paths, 'r') as file:\n        # Zugriff auf den gew\u00fcnschten Datensatz\n        data = file[self.table_key][:]  # type: ignore\n\n    return data\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.preprocessing.Preprocess.get_abtastrate","title":"get_abtastrate","text":"<pre><code>get_abtastrate()\n</code></pre> <p>Get_abtastrate returns the sample_freq from the current .h5 file via Acoular</p> Source code in <code>src/fft_analysator/analysis/preprocessing.py</code> <pre><code>def get_abtastrate(self):\n    \"\"\"\n    Get_abtastrate returns the sample_freq from the current .h5 file via Acoular\n    \"\"\"\n    abtastrate = self.source.sample_freq\n    return abtastrate\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.preprocessing.Preprocess.get_channel_count","title":"get_channel_count","text":"<pre><code>get_channel_count()\n</code></pre> <p>Get_channel_count returns the number of channels of the current .h5 file</p> Source code in <code>src/fft_analysator/analysis/preprocessing.py</code> <pre><code>def get_channel_count(self):\n    \"\"\"\n    Get_channel_count returns the number of channels of the current .h5 file\n    \"\"\"\n    count = self.source.numchannels\n    return count\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.preprocessing.Preprocess.get_channel_size","title":"get_channel_size","text":"<pre><code>get_channel_size()\n</code></pre> <p>Get_channel_size returns the size of the current channel</p> Source code in <code>src/fft_analysator/analysis/preprocessing.py</code> <pre><code>def get_channel_size(self):\n    \"\"\"\n    Get_channel_size returns the size of the current channel\n    \"\"\"\n    size = np.array(self.converted_file)[:, self.current_channel].shape[0]\n    return size\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.preprocessing.Preprocess.get_table_names","title":"get_table_names","text":"<pre><code>get_table_names()\n</code></pre> <p>Get_table_names returns a list of all data set keyword contained in the current .h5 File</p> Source code in <code>src/fft_analysator/analysis/preprocessing.py</code> <pre><code>def get_table_names(self):\n    \"\"\"\n    Get_table_names returns a list of all data set keyword contained in the current .h5 File\n    \"\"\"\n    with h5py.File(self.file_paths, 'r') as file:\n        # Zugriff auf den gew\u00fcnschten Datensatz\n        keys = list(file.keys())\n\n    return keys\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.preprocessing.Preprocess.reinitialize_source","title":"reinitialize_source","text":"<pre><code>reinitialize_source()\n</code></pre> <p>The reinitialize_source function reinitializes the generator from Acoular. It is used for returning to already viewed data blocks.</p> Source code in <code>src/fft_analysator/analysis/preprocessing.py</code> <pre><code>def reinitialize_source(self):\n    \"\"\"\n    The reinitialize_source function reinitializes the generator from Acoular. It is used for returning to already\n    viewed data blocks.\n    \"\"\"\n    self.current_block_idx = 0\n    self.source = ac.TimeSamples(name=self.file_paths)\n    self.source_result = self.source.result(num=self.block_size)\n    self.selected_data_block = next(self.source_result)\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.preprocessing.Preprocess.set_channel_data","title":"set_channel_data","text":"<pre><code>set_channel_data(channel)\n</code></pre> <p>Set_channel_data sets returns the complete channel by iterating over the generator of Acoular and saving the data blocks in a Numpy Array.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>Channel number.</p> required Source code in <code>src/fft_analysator/analysis/preprocessing.py</code> <pre><code>def set_channel_data(self, channel):\n    \"\"\"\n    Set_channel_data sets returns the complete channel by iterating over the generator of Acoular and\n    saving the data blocks in a Numpy Array.\n\n    Args:\n        channel (int): Channel number.\n    \"\"\"\n    loop_list = []\n    for data in self.source_result:\n        loop_list.extend(data[:, channel])\n    self.selected_channel_data = np.array(loop_list)\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.preprocessing.Preprocess.set_channel_on_data_block","title":"set_channel_on_data_block","text":"<pre><code>set_channel_on_data_block(channel)\n</code></pre> <p>Set_channel_data_on_data_block sets returns the block data of a channel as a Numpy Array.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>Channel number.</p> required Source code in <code>src/fft_analysator/analysis/preprocessing.py</code> <pre><code>def set_channel_on_data_block(self, channel):\n    \"\"\"\n    Set_channel_data_on_data_block sets returns the block data of a channel as a Numpy Array.\n\n    Args:\n        channel (int): Channel number.\n    \"\"\"\n    return self.selected_data_block[:, channel]\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.preprocessing.Preprocess.set_current_channel","title":"set_current_channel","text":"<pre><code>set_current_channel(channel)\n</code></pre> <p>Set_current_channel sets the attribute current_channel by taking a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>Channel number switching to.</p> required Source code in <code>src/fft_analysator/analysis/preprocessing.py</code> <pre><code>def set_current_channel(self, channel):\n    \"\"\"\n    Set_current_channel sets the attribute current_channel by taking a channel.\n\n    Args:\n        channel (int): Channel number switching to.\n    \"\"\"\n    self.current_channel = channel\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.preprocessing.Preprocess.set_data_block_to_idx","title":"set_data_block_to_idx","text":"<pre><code>set_data_block_to_idx(idx)\n</code></pre> <p>Set_data_block_to_idx sets the attribute selected_data_block by selecting a specific element of the generator from Acoular and saving this data blocks in a Numpy Array.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>Idx element to which the generator iterates to.</p> required Source code in <code>src/fft_analysator/analysis/preprocessing.py</code> <pre><code>def set_data_block_to_idx(self, idx):\n    \"\"\"\n    Set_data_block_to_idx sets the attribute selected_data_block by selecting a specific element of\n    the generator from Acoular and saving this data blocks in a Numpy Array.\n\n    Args:\n        idx (int): Idx element to which the generator iterates to.\n    \"\"\"\n    self.reinitialize_source()\n    try:\n        self.current_block_idx = idx\n        if idx &gt; 0:\n            for i in range(idx):\n                self.selected_data_block = next(self.source_result)\n        print('previous')\n    except StopIteration:\n        print('End of file reached')\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.preprocessing.Preprocess.set_next_data_block","title":"set_next_data_block","text":"<pre><code>set_next_data_block()\n</code></pre> <p>Set_next_data_block sets the attribute selected_data_block by selecting the next element of the generator from Acoular and saving this data blocks in a Numpy Array.</p> Source code in <code>src/fft_analysator/analysis/preprocessing.py</code> <pre><code>def set_next_data_block(self):\n    \"\"\"\n    Set_next_data_block sets the attribute selected_data_block by selecting the next element of\n    the generator from Acoular and saving this data blocks in a Numpy Array.\n    \"\"\"\n    self.current_block_idx += 1\n    self.selected_data_block = next(self.source_result)\n    print('next')\n</code></pre>"},{"location":"dev_backend_documentation/#signal-processing","title":"Signal Processing","text":""},{"location":"dev_backend_documentation/#fft_analysator.analysis.signal_processing","title":"signal_processing","text":""},{"location":"dev_frontend_documentation/","title":"Frontend Documentation","text":""},{"location":"dev_frontend_documentation/#fft_analysator.gui.views.sidebar","title":"sidebar","text":""},{"location":"dev_frontend_documentation/#fft_analysator.gui.views.sidebar.Sidebar","title":"Sidebar","text":"<pre><code>Sidebar(callback_fileupload=None, callback=None, callback_table_chooser=None, callback_intslider=None, callback_block_selector=None, callback_analysis_event=None)\n</code></pre> Source code in <code>src/fft_analysator/gui/views/sidebar.py</code> <pre><code>def __init__(self, callback_fileupload=None, callback=None, callback_table_chooser=None, callback_intslider=None,\n             callback_block_selector=None, callback_analysis_event=None):\n\n    self.accordion = Accordion()\n    self.layout = self.accordion.component\n\n    if callback or callback_fileupload or callback_table_chooser or callback_analysis_event:\n        self.accordion.file_input.component.param.watch(callback_fileupload, \"value\")\n        self.accordion.stretching_switch.component.param.watch(callback, \"value\")\n        self.accordion.channel_selector_input.component.param.watch(callback, \"value\")\n        self.accordion.channel_selector_output.component.param.watch(callback, \"value\")\n        self.accordion.color_picker_ch1.component.param.watch(callback, \"value\")\n        self.accordion.color_picker_ch2.component.param.watch(callback, \"value\")\n        self.accordion.color_picker_result.component.param.watch(callback, \"value\")\n        self.accordion.selector.component.param.watch(callback_table_chooser, \"value\")\n        self.accordion.int_slider.component.param.watch(callback_intslider, \"value\")\n        self.accordion.blocksize_selector.component.param.watch(callback_block_selector, \"value\")\n        self.accordion.calculation_menu.signal_menu.param.watch(callback_analysis_event, \"clicked\")\n</code></pre>"},{"location":"dev_frontend_documentation/#fft_analysator.gui.views.sidebar.Sidebar.update_channel_selector","title":"update_channel_selector","text":"<pre><code>update_channel_selector(data_callback=None)\n</code></pre> <p>The update_channel_selector function is used to update the update_channel_selector component with new data. If a data_callback is provided, then the options of the update_channel_selector component are set to be the number of channels in that callback. The name of the component is also updated accordingly. Otherwise, if no data_callback was provided, then we assume that there's no file selected and we set both options and name to empty lists/strings respectively.</p> <p>Parameters:</p> Name Type Description Default <code>data_callback</code> <code>object</code> <p>Get the callback to the data object</p> <code>None</code> Source code in <code>src/fft_analysator/gui/views/sidebar.py</code> <pre><code>def update_channel_selector(self, data_callback=None):\n    \"\"\"\n    The update_channel_selector function is used to update the update_channel_selector component with new data.\n    If a data_callback is provided, then the options of the update_channel_selector component are set to be\n    the number of channels in that callback. The name of the component is also updated accordingly.\n    Otherwise, if no data_callback was provided, then we assume that there's no file selected and\n    we set both options and name to empty lists/strings respectively.\n\n    Args:\n        data_callback (object): Get the callback to the data object\n    \"\"\"\n    if data_callback:\n        self.accordion.channel_selector_output.component.disabled = False\n        self.accordion.channel_selector_input.component.disabled = False\n        self.accordion.channel_selector_output.component.name = \"Output channel:\"\n        self.accordion.channel_selector_input.component.name = \"Input channel:\"\n        self.accordion.channel_selector_input.component.options = (list(range(data_callback.get_channel_count())))\n        self.accordion.channel_selector_output.component.options = (list(range(data_callback.get_channel_count())))\n\n    else:\n        self.accordion.channel_selector_output.component.name = \"No data chosen!\"\n        self.accordion.channel_selector_input.component.name = \"No data chosen!\"\n        self.accordion.channel_selector_input.component.options = []\n        self.accordion.channel_selector_output.component.options = []\n        self.accordion.channel_selector_output.component.disabled = True\n        self.accordion.channel_selector_input.component.disabled = True\n</code></pre>"}]}