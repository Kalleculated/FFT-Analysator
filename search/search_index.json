{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":"<p>Das ist die Dokumentation f\u00fcr den FFT-Analysator.</p>"},{"location":"dev_backend_documentation/","title":"Backend Documentation","text":""},{"location":"dev_backend_documentation/#preprocessing","title":"Preprocessing","text":""},{"location":"dev_backend_documentation/#fft_analysator.analysis.preprocessing","title":"preprocessing","text":""},{"location":"dev_backend_documentation/#fft_analysator.analysis.preprocessing.Preprocess","title":"Preprocess","text":"<pre><code>Preprocess(file_paths=None, block_size=1024)\n</code></pre> <p>The Preprocess class handles everything after importing the user file. It is an interface between Acoular and our internal Signalprocessing class. It contains information about the block size, data, channel count and size and sample frequency. It is able to return the complete data as a Numpy array or iterate over the defined block size.</p> <p>Parameters:</p> Name Type Description Default <code>file_paths</code> <code>object</code> <p>Get the callback to the data object</p> <code>None</code> <code>block_size</code> <code>int</code> <p>Length of data block.</p> <code>1024</code> Source code in <code>src/fft_analysator/analysis/preprocessing.py</code> <pre><code>def __init__(self, file_paths=None, block_size=1024):\n\n    self.file_paths = file_paths\n    self.block_size = block_size\n\n    if file_paths:\n        self.table_key = self.get_table_names()[0]\n        self.converted_file = self.convert_data()\n        self.source = ac.TimeSamples(name=self.file_paths)\n        self.source_result = self.source.result(num=self.block_size)\n        self.selected_data_block = next(self.source_result)\n\n    self.current_block_idx = 0\n\n    # brauchen wir das wirklich alles? wir sollten wirklich schauen, was wir als Attribut speichern\n    # oft lohnt sich returnen und in der plot function weiterverarbeiten mehr\n    self.data = None\n    self.channel_count = None\n    self.channel_size = None\n    self.selected_channel_data = np.array([])\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.preprocessing.Preprocess.convert_data","title":"convert_data","text":"<pre><code>convert_data()\n</code></pre> <p>Convert_data reads the .h5 file and reads the data. Not used for Signalprocessing.</p> Source code in <code>src/fft_analysator/analysis/preprocessing.py</code> <pre><code>def convert_data(self):\n    \"\"\"\n    Convert_data reads the .h5 file and reads the data. Not used for Signalprocessing.\n    \"\"\"\n    with h5py.File(self.file_paths, 'r') as file:\n        # Zugriff auf den gew\u00fcnschten Datensatz\n        data = file[self.table_key][:]  # type: ignore\n\n    return data\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.preprocessing.Preprocess.get_abtastrate","title":"get_abtastrate","text":"<pre><code>get_abtastrate()\n</code></pre> <p>Get_abtastrate returns the sample_freq from the current .h5 file via Acoular</p> Source code in <code>src/fft_analysator/analysis/preprocessing.py</code> <pre><code>def get_abtastrate(self):\n    \"\"\"\n    Get_abtastrate returns the sample_freq from the current .h5 file via Acoular\n    \"\"\"\n    abtastrate = self.source.sample_freq\n    return abtastrate\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.preprocessing.Preprocess.get_channel_count","title":"get_channel_count","text":"<pre><code>get_channel_count()\n</code></pre> <p>Get_channel_count returns the number of channels of the current .h5 file</p> Source code in <code>src/fft_analysator/analysis/preprocessing.py</code> <pre><code>def get_channel_count(self):\n    \"\"\"\n    Get_channel_count returns the number of channels of the current .h5 file\n    \"\"\"\n    count = self.source.numchannels\n    return count\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.preprocessing.Preprocess.get_channel_size","title":"get_channel_size","text":"<pre><code>get_channel_size()\n</code></pre> <p>Get_channel_size returns the size of the current channel</p> Source code in <code>src/fft_analysator/analysis/preprocessing.py</code> <pre><code>def get_channel_size(self):\n    \"\"\"\n    Get_channel_size returns the size of the current channel\n    \"\"\"\n    size = np.array(self.converted_file)[:, self.current_channel].shape[0]\n    return size\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.preprocessing.Preprocess.get_table_names","title":"get_table_names","text":"<pre><code>get_table_names()\n</code></pre> <p>Get_table_names returns a list of all data set keyword contained in the current .h5 File</p> Source code in <code>src/fft_analysator/analysis/preprocessing.py</code> <pre><code>def get_table_names(self):\n    \"\"\"\n    Get_table_names returns a list of all data set keyword contained in the current .h5 File\n    \"\"\"\n    with h5py.File(self.file_paths, 'r') as file:\n        # Zugriff auf den gew\u00fcnschten Datensatz\n        keys = list(file.keys())\n\n    return keys\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.preprocessing.Preprocess.reinitialize_source","title":"reinitialize_source","text":"<pre><code>reinitialize_source()\n</code></pre> <p>The reinitialize_source function reinitializes the generator from Acoular. It is used for returning to already viewed data blocks.</p> Source code in <code>src/fft_analysator/analysis/preprocessing.py</code> <pre><code>def reinitialize_source(self):\n    \"\"\"\n    The reinitialize_source function reinitializes the generator from Acoular. It is used for returning to already\n    viewed data blocks.\n    \"\"\"\n    self.current_block_idx = 0\n    self.source = ac.TimeSamples(name=self.file_paths)\n    self.source_result = self.source.result(num=self.block_size)\n    self.selected_data_block = next(self.source_result)\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.preprocessing.Preprocess.set_channel_data","title":"set_channel_data","text":"<pre><code>set_channel_data(channel)\n</code></pre> <p>Set_channel_data sets returns the complete channel by iterating over the generator of Acoular and saving the data blocks in a Numpy Array.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>Channel number.</p> required Source code in <code>src/fft_analysator/analysis/preprocessing.py</code> <pre><code>def set_channel_data(self, channel):\n    \"\"\"\n    Set_channel_data sets returns the complete channel by iterating over the generator of Acoular and\n    saving the data blocks in a Numpy Array.\n\n    Args:\n        channel (int): Channel number.\n    \"\"\"\n    loop_list = []\n    for data in self.source_result:\n        loop_list.extend(data[:, channel])\n    self.selected_channel_data = np.array(loop_list)\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.preprocessing.Preprocess.set_channel_on_data_block","title":"set_channel_on_data_block","text":"<pre><code>set_channel_on_data_block(channel)\n</code></pre> <p>Set_channel_data_on_data_block sets returns the block data of a channel as a Numpy Array.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>Channel number.</p> required Source code in <code>src/fft_analysator/analysis/preprocessing.py</code> <pre><code>def set_channel_on_data_block(self, channel):\n    \"\"\"\n    Set_channel_data_on_data_block sets returns the block data of a channel as a Numpy Array.\n\n    Args:\n        channel (int): Channel number.\n    \"\"\"\n    return self.selected_data_block[:, channel]\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.preprocessing.Preprocess.set_current_channel","title":"set_current_channel","text":"<pre><code>set_current_channel(channel)\n</code></pre> <p>Set_current_channel sets the attribute current_channel by taking a channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>int</code> <p>Channel number switching to.</p> required Source code in <code>src/fft_analysator/analysis/preprocessing.py</code> <pre><code>def set_current_channel(self, channel):\n    \"\"\"\n    Set_current_channel sets the attribute current_channel by taking a channel.\n\n    Args:\n        channel (int): Channel number switching to.\n    \"\"\"\n    self.current_channel = channel\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.preprocessing.Preprocess.set_data_block_to_idx","title":"set_data_block_to_idx","text":"<pre><code>set_data_block_to_idx(idx)\n</code></pre> <p>Set_data_block_to_idx sets the attribute selected_data_block by selecting a specific element of the generator from Acoular and saving this data blocks in a Numpy Array.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>Idx element to which the generator iterates to.</p> required Source code in <code>src/fft_analysator/analysis/preprocessing.py</code> <pre><code>def set_data_block_to_idx(self, idx):\n    \"\"\"\n    Set_data_block_to_idx sets the attribute selected_data_block by selecting a specific element of\n    the generator from Acoular and saving this data blocks in a Numpy Array.\n\n    Args:\n        idx (int): Idx element to which the generator iterates to.\n    \"\"\"\n    self.reinitialize_source()\n    try:\n        self.current_block_idx = idx\n        if idx &gt; 0:\n            for i in range(idx):\n                self.selected_data_block = next(self.source_result)\n        print('previous')\n    except StopIteration:\n        print('End of file reached')\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.preprocessing.Preprocess.set_next_data_block","title":"set_next_data_block","text":"<pre><code>set_next_data_block()\n</code></pre> <p>Set_next_data_block sets the attribute selected_data_block by selecting the next element of the generator from Acoular and saving this data blocks in a Numpy Array.</p> Source code in <code>src/fft_analysator/analysis/preprocessing.py</code> <pre><code>def set_next_data_block(self):\n    \"\"\"\n    Set_next_data_block sets the attribute selected_data_block by selecting the next element of\n    the generator from Acoular and saving this data blocks in a Numpy Array.\n    \"\"\"\n    self.current_block_idx += 1\n    self.selected_data_block = next(self.source_result)\n    print('next')\n</code></pre>"},{"location":"dev_backend_documentation/#signal-processing","title":"Signal Processing","text":""},{"location":"dev_backend_documentation/#fft_analysator.analysis.signal_processing","title":"signal_processing","text":""},{"location":"dev_backend_documentation/#fft_analysator.analysis.signal_processing.Signal_Process","title":"Signal_Process","text":"<pre><code>Signal_Process(channels, file_path, window='Hanning', block_size=1024, overlap='50%')\n</code></pre> <p>The Signal_Process class handles every signal processing method block-wise and returns its results as a Numpy Array. It is initialized by a required the file_path, a window option for the Fourier transformation, a given block_size and an Overlap percentage. Possible signal processing are CSM calculation (Cross Spectral Matrix), coherence between two signals, frequency and impulse response between input and output data and cross/auto correlation between two given signals.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>object</code> <p>Get the callback to the data object</p> required <code>window</code> <code>string</code> <p>window function for the fourier transformation: Allowed options: 'Rectangular','Hanning',</p> <code>'Hanning'</code> <code>block_size</code> <code>int</code> <p>Length of data block. Allowed values: 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536</p> <code>1024</code> <code>overlap</code> <code>string</code> <p>Overlap percentage between two blocks for the Welch-Method. Allowed options: 'None','50%',</p> <code>'50%'</code> Source code in <code>src/fft_analysator/analysis/signal_processing.py</code> <pre><code>def __init__(self, channels, file_path, window='Hanning', block_size=1024, overlap='50%'):\n    self.file_path = file_path\n    self.window = window\n    self.block_size = block_size\n    self.overlap = overlap\n    self.channels = channels\n\n    if file_path:\n\n        self.source = ac.MaskedTimeSamples(name=self.file_path)\n        self.abtastrate = self.source.sample_freq\n        self.numchannels_total = self.source.numchannels_total\n        #self.invalid_channel_list = []\n        #self.powerspectra = None\n\n        if channels:\n            if len(channels) == 1:\n                self.input_channel = self.channels[0]\n                self.output_channel = self.channels[0]\n            else:\n                self.input_channel = self.channels[0]\n                self.output_channel = self.channels[1]\n\n\n        self.invalid_channels([self.input_channel, self.output_channel])\n        self.powerspectra = ac.PowerSpectra(time_data=self.source, block_size=self.block_size, window=self.window, overlap=self.overlap)\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.signal_processing.Signal_Process.coherence","title":"coherence","text":"<pre><code>coherence()\n</code></pre> <p>The coherence function calculates the coherence between two given signals.</p> <p>Parameters:</p> Name Type Description Default <code>signal_x</code> <code>numpy array</code> <p>Input signal defined by the user</p> required <code>signal_y</code> <code>numpy array</code> <p>Output signal defined by the user</p> required Source code in <code>src/fft_analysator/analysis/signal_processing.py</code> <pre><code>def coherence(self):\n    \"\"\"\n    The coherence function calculates the coherence between two given signals.\n\n    Args:\n        signal_x (numpy array): Input signal defined by the user\n        signal_y (numpy array): Output signal defined by the user\n    \"\"\"\n    csm_matrix = self.csm()\n\n    if self.input_channel == self.output_channel:\n        coherence = np.abs(csm_matrix[:, 0, 0].real)**2 / (csm_matrix[:, 0, 0].real * csm_matrix[:, 0, 0].real)\n    else:\n        coherence = np.abs(csm_matrix[:, 0, 1])**2 / (csm_matrix[:, 0, 0].real * csm_matrix[:, 1, 1].real)\n\n    return coherence\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.signal_processing.Signal_Process.correlation","title":"correlation","text":"<pre><code>correlation(type=None)\n</code></pre> <p>The correlation function calculates the correlation response between the two given signals.</p> <p>Parameters:</p> Name Type Description Default <code>signal_x</code> <code>numpy array</code> <p>Input signal defined by the user</p> required <code>signal_y</code> <code>numpy array</code> <p>Output signal defined by the user</p> required <code>type</code> <code>string</code> <p>Determines if an auto or cross correlation is being calculated. Allowed options: 'xx', 'yy', 'xy'</p> <code>None</code> Source code in <code>src/fft_analysator/analysis/signal_processing.py</code> <pre><code>def correlation(self,type=None):\n    \"\"\"\n    The correlation function calculates the correlation response between the two given signals.\n\n    Args:\n        signal_x (numpy array): Input signal defined by the user\n        signal_y (numpy array): Output signal defined by the user\n        type (string): Determines if an auto or cross correlation is being calculated. Allowed options: 'xx', 'yy', 'xy'\n    \"\"\"\n    csm_matrix = self.csm()\n    N = len(csm_matrix[:, 0, 0])\n\n    if type == 'xx':\n        corr = np.fft.fftshift(np.fft.irfft(csm_matrix[:, 0, 0].real, n=N))\n    elif type == 'yy':\n        if self.input_channel == self.output_channel:\n            corr = np.fft.fftshift(np.fft.irfft(csm_matrix[:, 0, 0].real, n=N))\n        else:\n            corr = np.fft.fftshift(np.fft.irfft(csm_matrix[:, 1, 1].real, n=N))\n    elif type == 'xy':\n        if self.input_channel == self.output_channel:\n            corr = np.fft.fftshift(np.fft.irfft(csm_matrix[:, 0, 0].real, n=N))\n        else:\n            corr = np.fft.fftshift(np.fft.irfft(csm_matrix[:, 0, 1], n=N))\n\n    #return np.roll(corr / np.max(np.abs(corr)), N//2)\n    return corr / np.max(np.abs(corr))\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.signal_processing.Signal_Process.create_correlation_axis","title":"create_correlation_axis","text":"<pre><code>create_correlation_axis(N)\n</code></pre> <p>The create_correlation_axis function creates the x-Axis for the correlation function Args:     N (int): Size of the axis</p> Source code in <code>src/fft_analysator/analysis/signal_processing.py</code> <pre><code>def create_correlation_axis(self, N):\n    \"\"\"\n    The create_correlation_axis function creates the x-Axis for the correlation function\n    Args:\n        N (int): Size of the axis\n    \"\"\"\n\n    time_delay = np.arange(-N/2,N/2) * 100 / self.abtastrate\n    return time_delay\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.signal_processing.Signal_Process.create_frequency_axis","title":"create_frequency_axis","text":"<pre><code>create_frequency_axis()\n</code></pre> <p>The create_frequency_axis function creates the x-Axis for the frequency function</p> Source code in <code>src/fft_analysator/analysis/signal_processing.py</code> <pre><code>def create_frequency_axis(self):\n    \"\"\"\n    The create_frequency_axis function creates the x-Axis for the frequency function\n    \"\"\"\n\n    return self.powerspectra.fftfreq()\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.signal_processing.Signal_Process.create_time_axis","title":"create_time_axis","text":"<pre><code>create_time_axis(N)\n</code></pre> <p>The create_time_axis function creates a time axis for the x-Axis Args:     N (int): Size of the axis</p> Source code in <code>src/fft_analysator/analysis/signal_processing.py</code> <pre><code>def create_time_axis(self, N):\n    \"\"\"\n    The create_time_axis function creates a time axis for the x-Axis\n    Args:\n        N (int): Size of the axis\n    \"\"\"\n\n    time_axis = np.arange(N) / self.abtastrate\n    return time_axis\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.signal_processing.Signal_Process.csm","title":"csm","text":"<pre><code>csm(csm_dB=False)\n</code></pre> <p>The csm function calculates the csm (Cross Spectral Matrix) of Acoular for the valid signals. It returns a three-dimensional array with size (number of frequencies,2,2) where [:, signal1, signal2] is the Cross spectral density between signal1 and signal2.</p> <p>Parameters:</p> Name Type Description Default <code>signal_x</code> <code>numpy array</code> <p>Input signal defined by the user</p> required <code>signal_y</code> <code>numpy array</code> <p>Output signal defined by the user</p> required <code>window</code> <code>string</code> <p>window function for the fourier transformation: Allowed options: 'Rectangular','Hanning',</p> required <code>block_size</code> <code>int</code> <p>Length of data block. Allowed values: 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536</p> required <code>overlap</code> <code>string</code> <p>Overlap percentage between two blocks for the Welch-Method. Allowed options: 'None','50%',</p> required <code>db</code> <code>boolean</code> <p>Return the array in dB values.</p> required Source code in <code>src/fft_analysator/analysis/signal_processing.py</code> <pre><code>def csm(self,csm_dB=False):\n    \"\"\"\n    The csm function calculates the csm (Cross Spectral Matrix) of Acoular for the valid signals. It returns a\n    three-dimensional array with size (number of frequencies,2,2) where [:, signal1, signal2] is the\n    Cross spectral density between signal1 and signal2.\n\n    Args:\n        signal_x (numpy array): Input signal defined by the user\n        signal_y (numpy array): Output signal defined by the user\n        window (string): window function for the fourier transformation: Allowed options: 'Rectangular','Hanning',\n        'Hamming', 'Bartlett', 'Blackman'\n        block_size (int): Length of data block. Allowed values: 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536\n        overlap (string): Overlap percentage between two blocks for the Welch-Method. Allowed options: 'None','50%',\n        '75%','87.5%'\n        db (boolean): Return the array in dB values.\n\n    \"\"\"\n    # Autopowerspec from signal_x --&gt; self.powerspectra[:,0,0]\n    # Autopowerspec from signal_y --&gt; self.powerspectra[:,1,1]\n    # Crosspowerspec from x and y --&gt; self.powerspectra[:,0,1]\n    #self.invalid_channels([signal_x, signal_y])\n    #self.powerspectra = ac.PowerSpectra(time_data=self.source, block_size=block_size, window=window, overlap=overlap)\n\n    if csm_dB:\n        return 10*np.log10(self.powerspectra.csm)\n    else:\n        return self.powerspectra.csm\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.signal_processing.Signal_Process.frequency_response","title":"frequency_response","text":"<pre><code>frequency_response(frq_rsp_dB=True)\n</code></pre> <p>The frequency_response function calculates the frequency response between the input and output signal. It uses the H1 estimator H1 = Gxy / Gxx, where Gxy is the Cross Spectral density between signal x and signal y and Gxx is the Power Spectral Density of signal x.</p> <p>Parameters:</p> Name Type Description Default <code>signal_x</code> <code>numpy array</code> <p>Input signal defined by the user</p> required <code>signal_y</code> <code>numpy array</code> <p>Output signal defined by the user</p> required <code>db</code> <code>boolean</code> <p>Return the array ian dB values.</p> required Source code in <code>src/fft_analysator/analysis/signal_processing.py</code> <pre><code>def frequency_response(self, frq_rsp_dB=True):\n    \"\"\"\n    The frequency_response function calculates the frequency response between the input and output signal.\n    It uses the H1 estimator H1 = Gxy / Gxx, where Gxy is the Cross Spectral density between signal x and signal y\n    and Gxx is the Power Spectral Density of signal x.\n\n    Args:\n        signal_x (numpy array): Input signal defined by the user\n        signal_y (numpy array): Output signal defined by the user\n        db (boolean): Return the array ian dB values.\n    \"\"\"\n    csm_matrix = self.csm()\n\n    if self.input_channel == self.output_channel:\n        H = np.divide(csm_matrix[:, 0, 0].real, csm_matrix[:, 0, 0].real, out=np.zeros_like(csm_matrix[:, 0, 0].real), where=(np.abs(csm_matrix[:, 0, 0].real) &gt; 1e-10))\n    else:\n        H = np.divide(csm_matrix[:, 0, 1], csm_matrix[:, 0, 0].real, out=np.zeros_like(csm_matrix[:, 0, 1]), where=(np.abs(csm_matrix[:, 0, 1]) &gt; 1e-10))\n    if frq_rsp_dB:\n        return 20*np.log10(abs(np.squeeze(H)))\n    else:\n        return np.abs(np.squeeze(H))\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.signal_processing.Signal_Process.impuls_response","title":"impuls_response","text":"<pre><code>impuls_response()\n</code></pre> <p>The impulse_response function calculates the impulse response between the input and output signal. It uses the H1 estimator H1 = Gxy / Gxx, where Gxy is the Spectral density between signal x and signal y and Gxx is the Power Spectral Density of signal x.</p> <p>Parameters:</p> Name Type Description Default <code>signal_x</code> <code>numpy array</code> <p>Input signal defined by the user</p> required <code>signal_y</code> <code>numpy array</code> <p>Output signal defined by the user</p> required Source code in <code>src/fft_analysator/analysis/signal_processing.py</code> <pre><code>def impuls_response(self):\n    \"\"\"\n    The impulse_response function calculates the impulse response between the input and output signal.\n    It uses the H1 estimator H1 = Gxy / Gxx, where Gxy is the Spectral density between signal x and signal y\n    and Gxx is the Power Spectral Density of signal x.\n\n    Args:\n        signal_x (numpy array): Input signal defined by the user\n        signal_y (numpy array): Output signal defined by the user\n    \"\"\"\n    csm_matrix = self.csm()\n    if self.input_channel == self.output_channel:\n        H = np.divide(csm_matrix[:, 0, 0].real, csm_matrix[:, 0, 0].real, out=np.zeros_like(csm_matrix[:, 0, 0].real), where=(np.abs(csm_matrix[:, 0, 0].real) &gt; 1e-10))\n    else:\n        H = np.divide(csm_matrix[:, 0, 1], csm_matrix[:, 0, 0].real, out=np.zeros_like(csm_matrix[:, 0, 1]), where=(np.abs(csm_matrix[:, 0, 1]) &gt; 1e-10))\n\n    N = len(csm_matrix[:, 0, 0])\n    #h = fft.irfft(H, n=N)\n    h = np.fft.irfft(H, n=N)\n    return h\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.signal_processing.Signal_Process.invalid_channels","title":"invalid_channels","text":"<pre><code>invalid_channels(valid_channels)\n</code></pre> <p>The invalid_channels function fills the invalid_channel_list with two valid channels chosen by the user. Args:     valid_channels (list): Contains the two selected channels chosen by the user.</p> Source code in <code>src/fft_analysator/analysis/signal_processing.py</code> <pre><code>def invalid_channels(self, valid_channels):\n    \"\"\"\n    The invalid_channels function fills the invalid_channel_list with two valid channels chosen by the user.\n    Args:\n        valid_channels (list): Contains the two selected channels chosen by the user.\n    \"\"\"\n\n    self.invalid_channel_list = [k for k in range(self.numchannels_total) if k not in valid_channels]\n    self.source.invalid_channels = self.invalid_channel_list\n</code></pre>"},{"location":"dev_backend_documentation/#fft_analysator.analysis.signal_processing.Signal_Process.phase_response","title":"phase_response","text":"<pre><code>phase_response(deg=True)\n</code></pre> <p>The phase_response function calculates the phase response between the input and output signal. It uses the H1 estimator H1 = Gxy / Gxx, where Gxy is the Cross Spectral Density between signal x and signal y and Gxx is the Power Spectral Density of signal x.</p> <p>Parameters:</p> Name Type Description Default <code>signal_x</code> <code>numpy array</code> <p>Input signal defined by the user</p> required <code>signal_y</code> <code>numpy array</code> <p>Output signal defined by the user</p> required <code>deg</code> <code>boolean</code> <p>Return the array in degrees</p> <code>True</code> Source code in <code>src/fft_analysator/analysis/signal_processing.py</code> <pre><code>def phase_response(self, deg=True):\n    \"\"\"\n    The phase_response function calculates the phase response between the input and output signal.\n    It uses the H1 estimator H1 = Gxy / Gxx, where Gxy is the Cross Spectral Density between signal x and signal y\n    and Gxx is the Power Spectral Density of signal x.\n\n    Args:\n        signal_x (numpy array): Input signal defined by the user\n        signal_y (numpy array): Output signal defined by the user\n        deg (boolean): Return the array in degrees\n    \"\"\"\n    csm_matrix = self.csm()\n\n    if self.input_channel == self.output_channel:\n        H = np.divide(csm_matrix[:, 0, 0].real, csm_matrix[:, 0, 0].real, out=np.zeros_like(csm_matrix[:, 0, 0].real), where=(np.abs(csm_matrix[:, 0, 0].real) &gt; 1e0))\n    else:\n        H = np.divide(csm_matrix[:, 0, 1], csm_matrix[:, 0, 0].real, out=np.zeros_like(csm_matrix[:, 0, 1]), where=(np.abs(csm_matrix[:, 0, 1]) &gt; 1e-10))\n\n    phase = np.angle(H,deg=deg)\n    return phase\n</code></pre>"},{"location":"dev_frontend_documentation/","title":"Frontend Documentation","text":""},{"location":"dev_frontend_documentation/#fft_analysator.gui.views.sidebar","title":"sidebar","text":""},{"location":"dev_frontend_documentation/#fft_analysator.gui.views.sidebar.Sidebar","title":"Sidebar","text":"<pre><code>Sidebar(callback_fileupload=None, callback=None, callback_table_chooser=None, callback_intslider=None, callback_block_selector=None, callback_analysis_event=None)\n</code></pre> Source code in <code>src/fft_analysator/gui/views/sidebar.py</code> <pre><code>def __init__(self, callback_fileupload=None, callback=None, callback_table_chooser=None, callback_intslider=None,\n             callback_block_selector=None, callback_analysis_event=None):\n\n    self.accordion = Accordion()\n    self.layout = self.accordion.component\n\n    if callback or callback_fileupload or callback_table_chooser or callback_analysis_event:\n        self.accordion.file_input.component.param.watch(callback_fileupload, \"value\")\n        self.accordion.stretching_switch.component.param.watch(callback, \"value\")\n        self.accordion.channel_selector_input.component.param.watch(callback, \"value\")\n        self.accordion.channel_selector_output.component.param.watch(callback, \"value\")\n        self.accordion.color_picker_ch1.component.param.watch(callback, \"value\")\n        self.accordion.color_picker_ch2.component.param.watch(callback, \"value\")\n        self.accordion.color_picker_result.component.param.watch(callback, \"value\")\n        self.accordion.selector.component.param.watch(callback_table_chooser, \"value\")\n        self.accordion.int_slider.component.param.watch(callback_intslider, \"value\")\n        self.accordion.blocksize_selector.component.param.watch(callback_block_selector, \"value\")\n        self.accordion.calculation_menu.signal_menu.param.watch(callback_analysis_event, \"clicked\")\n        self.accordion.overlap_menu.overlap_menu.param.watch(callback_analysis_event, \"clicked\")\n        self.accordion.window_menu.window_menu.param.watch(callback_analysis_event, \"clicked\")\n</code></pre>"},{"location":"dev_frontend_documentation/#fft_analysator.gui.views.sidebar.Sidebar.update_channel_selector","title":"update_channel_selector","text":"<pre><code>update_channel_selector(data_callback=None)\n</code></pre> <p>The update_channel_selector function is used to update the update_channel_selector component with new data. If a data_callback is provided, then the options of the update_channel_selector component are set to be the number of channels in that callback. The name of the component is also updated accordingly. Otherwise, if no data_callback was provided, then we assume that there's no file selected and we set both options and name to empty lists/strings respectively.</p> <p>Parameters:</p> Name Type Description Default <code>data_callback</code> <code>object</code> <p>Get the callback to the data object</p> <code>None</code> Source code in <code>src/fft_analysator/gui/views/sidebar.py</code> <pre><code>def update_channel_selector(self, data_callback=None):\n    \"\"\"\n    The update_channel_selector function is used to update the update_channel_selector component with new data.\n    If a data_callback is provided, then the options of the update_channel_selector component are set to be\n    the number of channels in that callback. The name of the component is also updated accordingly.\n    Otherwise, if no data_callback was provided, then we assume that there's no file selected and\n    we set both options and name to empty lists/strings respectively.\n\n    Args:\n        data_callback (object): Get the callback to the data object\n    \"\"\"\n    if data_callback:\n        self.accordion.channel_selector_output.component.disabled = False\n        self.accordion.channel_selector_input.component.disabled = False\n        self.accordion.channel_selector_output.component.name = \"Output channel:\"\n        self.accordion.channel_selector_input.component.name = \"Input channel:\"\n        self.accordion.channel_selector_input.component.options = (list(range(data_callback.get_channel_count())))\n        self.accordion.channel_selector_output.component.options = (list(range(data_callback.get_channel_count())))\n\n    else:\n        self.accordion.channel_selector_output.component.name = \"No data chosen!\"\n        self.accordion.channel_selector_input.component.name = \"No data chosen!\"\n        self.accordion.channel_selector_input.component.options = []\n        self.accordion.channel_selector_output.component.options = []\n        self.accordion.channel_selector_output.component.disabled = True\n        self.accordion.channel_selector_input.component.disabled = True\n</code></pre>"}]}